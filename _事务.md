---
title: 事务
excerpt: 满足ACID的一系列操作，要么全部成功，要么全部失败
date: 2023-07-12
tags: [数据库,分布式]
image:
---

引用一个经典的例子，小明的银行账户里面有100元钱，小红的银行账户里面也有100元钱，现在小明要给小红转账50元，对于银行来说，大致可以分为两步
1. 从小明的账户里扣除50元
2. 在小红的账户里增加50元

但是你想想，如果第一步成功了，第二步失败了，那么可怕的事情就发生了：小明辛辛苦苦打工赚来的50元钱凭空就消失了！！！

为了保证转账成功，事务就有了它的用武之地。首先来看下事务的基本概念：
**事务是由一系列操作组成的基本单位，满足原子性、一致性、隔离性和持久性的特性，要么全部成功执行，要么全部回滚到初始状态，确保数据的完整性和可靠性**

## 事务的特性
原子性
一致性
隔离性
持久性

## 本地事务
本地事务一般用数据库来实现，比如MySQL（基于InnoDB引擎），上诉转账的例子就可以通过下面的方式来实现：
```sql
-- 启动一个事务
start transaction
-- 执行业务
update account set money -= 50 where name = "小明";
update account set money += 50 where name = "小红";
-- 异常则回滚 否则提交
commit or rollback
```

在上面的代码中，业务代码中的任意环节出现异常，MySQL都会执行回滚操作，回滚之后，所有的记录都会回到事务启动之前的状态，就像什么都没发生一样。只有在正常提交之后，所有的业务操作才会生效。这样看起来，好像还很牛批的样子，那么MySQL是怎么实现的呢？或者更加正确地说，InnoDB是如何实现事务的呢？

### 隔离性
首先我们来说说事务的四大特性之一**隔离性**。隔离的意思就是，不同事务对于数据的操作是相互隔离的。当数据库上有多个事务同时执行的时候，就可能出现脏读、不可重复读、幻读的问题，为了解决这些问题，就有了**隔离级别**的概念
在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。SQL 标准的事务隔离级别包括：
+ **读未提交（read uncommitted）**：一个事务还没提交时，它做的变更就能被别的事务看到
+ **读提交（read committed）**：一个事务提交之后，它做的变更才会被其他事务看到
+ **可重复读（repeatable read）**：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的
+ **和串行化（serializable）**：顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行

### 事务隔离的实现
在实现上，数据库里面会创建一个**一致性视图**，访问的时候**以视图的逻辑结果为准**。在可重复读隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在读提交隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，读未提交隔离级别下直接返回记录上的最新值，没有视图概念；而串行化隔离级别下直接用加锁的方式来避免并行访问

上面说的**一致性视图**实际上就是数据库当前的一个快照，但是这看起来不太可能啊？如果一个数据库有100G，那么我每启动一个事物就会拷贝一个100G的快照，这得多慢啊！而且存储空间也顶不住啊！那InnoDB是怎么实现的呢？

### MVCC
我们再来看看其具体实现，以下讨论以“可重复读”展开

## 分布式事务
### 事务消息

> 参考：
[事务隔离：为什么你改了我还看不见？](https://time.geekbang.org/column/article/68963)
