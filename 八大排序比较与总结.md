---
title: 八大排序比较与总结
excerpt: 高效处理、组织、搜索数据
date: 2019-04-17 20:32:06
tags: 数据结构
toc: true
image: /img/theme/005.jpg
---

<center><img src="../../../../img/sort.png" width="80%" height="80%" /></center>

## 归并排序
归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法的一个非常典型的应用。其核心思想是将已有序的子序列合并，得到完全有序的序列：即先使每个子序列有序，再使子序列段间有序。算法实现如下：
```java
public class MergeSort {

    public static void sort(int[] a, int left, int right) {
        if (left < right) {
            int mid = left + ((right - left) >> 1);
            sort(a, left, mid);
            sort(a, mid + 1, right);
            mergeSort(a, left, mid, right);
        }
    }

    private static void mergeSort(int[] a, int left, int mid, int right) {
        int[] tem = new int[right - left + 1];
        int i = left, j = mid + 1, k = 0;
        while (i <= mid || j <= right) {
            if (j > right || (i <= mid && a[i] < a[j]))
                tem[k++] = a[i++];
            else
                tem[k++] = a[j++];
        }

        for (i = left, j = 0; j < k; i++, j++)
            a[i] = tem[j];
    }
}
```
## 快速排序
快速排序是对冒泡排序的一种改进，其基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据要小，然后再按照此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。
```java
public class QuickSort {

    public static void sort(int[] a, int left, int right) {
        if (left < right) {
            int i = left, j = right, x = a[left];
            while (i < j) {
                while (i < j && a[j] >= x) j--;
                if (i < j) a[i++] = a[j];
                while (i < j && a[i] <= x) i++;
                if (i < j) a[j--] = a[i];
            }
            a[i] = x;
            sort(a, left, i - 1);
            sort(a, i + 1, right);
        }
    }
}
```
## 堆排序
堆排序是指利用堆这种数据结构所设计的一种排序算法。而堆实际上是一颗完全二叉树，又分为大顶堆和小顶堆：
+ 大顶堆：根节点的键值是所有堆节点键值中的最大值，且每个节点的键值都比其孩子节点的键值大。
+ 小顶堆：根节点的键值是所有堆节点键值中的最小值，且每个节点的键值都比其孩子节点的键值小。

利用堆的这些性质，每次从堆中选出最大值或最小值就变得非常简单。代码实现从小到大排序：
```java
import java.util.Arrays;

public class HeapSort {
    public static void swap(int[] a, int i, int j) {
        int tem = a[i];
        a[i] = a[j];
        a[j] = tem;
    }

    public static void heapAdjust(int[] a, int i, int size) {
        int leftChild = 2 * i;
        int rightChild = 2 * i + 1;
        int max = i;
        if (i <= size / 2) {        //如果i是叶节点就不用进行调整，在递归的情况下可能出现叶节点的情况
            if(leftChild <= size && a[leftChild] > a[max]) {
                max = leftChild;
            }
            if(rightChild <= size && a[rightChild] > a[max]) {
                max = rightChild;
            }
            if(max != i) {
                swap(a, i, max);
                heapAdjust(a, max, size);    //避免调整之后以max为父节点的子树不是堆
            }
        }
    }

    public static void buildHeap(int[] a, int size) {
        int i;
        for (i = size / 2; i >= 1; i--)      //从非叶节点开始调整，非叶节点最大序号值为size/2
            heapAdjust(a, i, size);
    }

    public static void heapSort(int[] a, int size) {
        int i;
        buildHeap(a, size);
        for (i = size; i >= 1; i--) {
            swap(a, 1, i);           //交换堆顶和最后一个元素，即每次将剩余元素中的最大者放到最后面
            heapAdjust(a,1,i-1);      //重新调整堆顶节点成为大顶堆
        }
    }

    public static void main(String[] args) {
        // 数组从1开始计数
        //int[] a = {0, 16, 20, 3, 11, 17, 8};
        int[] a = {0, 51, 32, 73, 23, 42, 62, 99, 14, 24, 3943, 58, 65, 80, 120};
        int size = 14;
        int i;
        heapSort(a, size);
        System.out.println(Arrays.toString(a));
    }
}
```
关于堆排序的过程详解[点这里](https://www.cnblogs.com/chengxiao/p/6129630.html)
## 基数排序
```java
import java.util.Arrays;

public class RadixSort {

    private static final int RADIX = 10;

    // 取数字 x 从右往左的第 n 位数字
    private static int getDigit(int x, int n) {
        while (n > 1) {
            x /= 10;
            n--;
        }
        return x % 10;
    }

    public static void sort(int[] arr, int begin, int end, int d) {     //d 最大位数
        int[] count = new int[RADIX];
        int[] bucket = new int[end - begin + 1];    // 所有桶的空间开辟

        // 按照分配标准依次进行排序
        for (int k = 1; k <= d; k++) {
            Arrays.fill(count, 0);
            // 统计各个桶中所盛数据的个数
            for (int i = begin; i <= end; i++)
                count[getDigit(arr[i], k)]++;

            // count[i]表示第i个桶的右边界索引 + 1
            for (int i = 1; i < RADIX; i++)
                count[i] += count[i-1];

            // 把数据依次装入桶，因为 count[i] 表示第 i 个桶的右边界索引 + 1
            // 所以这里要从右向左扫描，保证排序的稳定性
            for (int i = end; i >= begin; i--) {
                int j = getDigit(arr[i], k);
                // 放入对应的桶中 count[i] - 1 是第 i 个桶的右边界索引
                // 并且对应桶的装入数据索引减一
                bucket[--count[j]] = arr[i];
            }

            // 此时 count[i] 表示第i个桶的左边界
            // 从桶中提取数据
            for (int i = begin, j = 0; i <= end; i++, j++)
                arr[i] = bucket[j];
        }
    }

    public static void main(String[] args) {
        int[] a = {20, 1324, 90, 0, 998, 965, 852, 123, 456, 789};
        sort(a, 0, a.length - 1, 4);
        System.out.println(Arrays.toString(a));
    }
}
```
## 希尔排序

希尔排序又称最小增量排序法，是一种基于插入思想的排序方法，是直接插入排序的改进算法。直接插入排序法，在待排序的关键字序列基本有序且关键字个数 n 较少时，其算法性能最佳，希尔排序就是利用了之一特性。首先，将待排序的关键字序列分成若干个较小的子序列，对子序列进行直接插入排序，使整个待排序序列最终变得有序。在时间耗费上，较直接插入排序法的性能有较大的改进。

在进行直接插入排序时，若待排序记录序列已经有序，直接插入排序法的时间复杂度可以提高到 O(n)。若待排序记录序列基本有序，即序列中具有下列特性的记录较少时：r[i].key < Max{r[j].key} (1 <= j < i)，直接插入排序的效率会大大提高。希尔排序正是基于以上两点对直接插入排序进行了改进。
```java
import java.util.Arrays;

public class ShellSort {

    public static void sort(int[] arr, int length) {
        int inc = length >> 1;
        while (inc > 0) {
            for (int i = inc; i < length; i++) {
                for (int j = i - inc; j >= 0 && arr[j] > arr[j + inc]; j -= inc) {
                    int tem = arr[j];
                    arr[j] = arr[j + inc];
                    arr[j + inc] = tem;
                }
            }
            inc >>= 1;
        }
    }

    public static void main(String[] args) {
        int[] a = {51, 0, 32, 73, 23, 42, 62, 99, 14, 24, 3943, 58, 65, 80, 120};
        sort(a, a.length);
        System.out.println(Arrays.toString(a));
    }
}
```

## Q&A

#### 1、为什么冒泡排序在最好情况下的时间复杂度为 O(n)？
冒泡排序的基本思想是：对相邻的元素进行两两比较，顺序相反则进行交换，这样每一趟遍历都会将最小或最大的元素“浮”到顶端，最终达到完全有序。最好的情况是对一个有序序列进行排序，**在一趟遍历后，发现一次交换都没做，那么就说明序列是有序的了**

#### 2、为什么选择排序是不稳定的？
例如，对 [5, 8, 5, 2, 9] 排序，第一趟之后需要把第一个 5 和 2 交换，这样原序列中的两个 5 的相对前后位置就被破坏了

#### 3、为什么快速排序在最坏情况下的时间复杂度为 O(n^2)？
最坏的情况是待排序的序列已经有序，例如 [1, 2, 3, 4, 5, 6, 7]，如果每次都取第一个元素作为比较元素，那么时间复杂度就会飙升至 O(n^2)

#### 4、为什么快速排序的空间复杂度为 O(logN)？
主要是递归造成的栈空间的使用，之前一直以为快排的空间复杂度为 O(1)，今天才发现递归调用的栈空间也要算进来。归并排序也用到了递归压栈，同时还用到了辅助数组，所以空间复杂度为 O(logn) + O(n)，但是就像 O(n) + O(n^2) ≈ O(n^2) 一样，O(logn) + O(n) ≈ O(n)，所以归并排序的空间复杂度为 O(n)（不知道这样理解对不对？）