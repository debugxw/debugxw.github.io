---
title: 协程VS线程
excerpt: Go在语言层面上提供的协程(goroutine)和通道(channel)两个基础并发原语，使得并发编程变得更加简单
date: 2023-06-26
tags: [并发,Golang,操作系统]
image: /img/theme/032.jpg
---

## Java线程 VS Golang协程

### Java线程

在Java语言中，我们想要新开一个线程去执行并发任务，就需要使用```new Thread(() -> { do something... }).start()```这样的方式去创建线程并执行任务。但是如果有大量的任务需要并发执行，我们还以这种方式去执行任务的话，缺点就显而易见，主要有以下两点：
+ 线程上下文切换、频繁的创建与销毁会带来严重的性能开销
+ 大量的线程同样会占用大量的系统资源，例如内存

为了解决这个问题，Java实现了线程版本的池化技术-**线程池**
线程池维护着一定数量的线程，并允许应用程序将任务派发给这些线程进行并行处理。线程池通过复用线程来执行并发任务，减少了线程数量，避免了反复创建和销毁线程所带来的性能开销。同时也给我们提供了易于使用的方式来管理、调度线程，使得线程在执行任务时更加高效。
但是线程池也有一个很大的问题，那就是线程池的线程数量如何设置，设置得多了，就会造成资源的浪费，少了又会造成任务堆积，所以设置合理的线程数量成了线程池的一大难题？在通用场景下我们可以根据任务是IO密集型、还是CPU密集型、以及具体业务场景来设置，但是我们的业务往往不是那么的通用。。。之前看到一篇美团的技术[文章](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)，通过实时监控线程池的状态来动态的调整线程池的数量，确实是一种比较好的思路！！！

### Golang协程

在Golang中想要实现类似于Java里面新开一个线程的功能，只需要使用```go func() { do something }```这样的方式，就可以执行并行任务，是不是比Java简单多了？而且在Golang中即使你创建大量的并发任务，也不会有上文所提到的性能开销和资源占用，因为本质上Golang中执行并发任务的载体不是线程，而是**协程**。那这个协程又是个什么东西呢？在了解它之前，我们先来看看操作系统的一些概念

## 进程、线程、协程

在计算机系统中，操作系统负责管理硬件资源并为应用程序提供服务，通常操作系统处于“内核空间”，而应用程序则处于“用户空间”

当一个应用程序需要请求操作系统提供某些服务时（例如读写磁盘、打印输出等），它就需要调用操作系统提供的接口，让操作系统来执行所需的操作。在此过程中，应用程序的权限将被限制，并且必须经过内核的检查和授权才能继续执行
由于内核和应用程序具有不同的权限和执行环境，因此在应用程序调用系统接口时，用户态和内核态之间进行切换是必须的。通过这种方式，**操作系统可以保护系统的安全性和稳定性，并防止应用程序对硬件资源造成损坏或滥用**。（有点类似于软件设计中的单一原则，系统服务就由我内核来实现，应用程序只需要调我给你提供的接口就行）

此外，内核还会负责处理系统中断、多任务管理、内存管理等底层任务，这些任务需要在内核态中执行。而在用户态中，应用程序则主要负责业务逻辑和数据处理等高级任务。因此，用户态和内核态之间的切换也是保证系统效率的重要手段

先来看看几个概念：

**进程**：进程是操作系统分配资源和进行调度的基本单位，每个进程都有独立的内存空间、文件描述符和其他系统资源，进程需要相对较大的系统开销，同时也可以使得多个线程共享资源，比如文件句柄和打开的网络连接等
**线程**：线程是CPU调度的基本单位，一个进程中可以有多个线程，这些线程共享进程的资源，如内存空间、文件句柄等，但每个线程都拥有自己的执行栈和程序计数器，使得它们可以并发地执行
**协程**：协程又被称为微线程，是一种用户态的轻量级线程。与线程不同的是，线程的调度由操作系统负责，而协程的调度则由应用程序控制

简单来理解，一个进程对应多个线程，一个线程对应多个协程：

![](../../../../img/os/进程-线程-协程.png)

### 内核级线程

在内核空间由内核创建的线程，内核在对其分配CPU资源时，是以内核级线程为调度单位。纯内核级线程程序有如下特点：
+ 进程中的一个线程被阻塞，内核能调度同一进程的其他线程（就绪态）占有处理器并执行任务
+ 多处理器环境中，内核能同时调度同一进程的多线程，将这些线程映射到不同的处理器核心上，提高进程的执行效率（这样可以实现并行）
+ 应用程序线程在用户态运行，线程调度和管理在内核实现。线程调度时，控制权从一个线程改变到另一线程，需要模式切换，系统开销较大

### 用户级线程

在用户空间通过操作系统程序库创建的线程，操作系统的内核是感知不到它的存在的。如果该进程没有创建内核级线程，那么内核在对其分配CPU资源时，依旧会以进程为调度单位。纯用户级线程程序有如下特点：
+ 线程切换不需要内核模式，能节省模式切换开销和内核资源
+ 允许进程按照特定的需要选择不同的调度算法来调度线程，调度算法需要自己实现
+ 由于其不需要内核进行支持，所以可以跨OS运行
+ 不能利用多核处理器的优势，内核调度以进程为单位，每个进程仅有一个用户级线程能执行
+ 一个用户级线程阻塞，将导致整个进程的阻塞

> 注意：这里所说的操作系统程序库和操作系统内核是两个不同的概念，它们有联系但也有区别
   > 操作系统程序库（Library）：操作系统内核是操作系统最核心的部分，通常是由一些高级语言不易编写的低级语言编写而成。其主要职责是管理和调度计算机的硬件资源，并提供相应的接口供上层应用程序或服务程序使用。内核是操作系统的核心，负责管理和分配处理器、内存、I/O 设备等底层硬件资源，为系统提供基本的服务和保障
   > 操作系统内核（Kernel）：操作系统程序库则是一组高级别的程序代码集合，为应用程序提供可重用的功能模块和服务。与内核不同，程序库是属于用户空间的，是在内核之上构建的。程序库包含了各种常用的函数和工具，可以被应用程序直接调用，比如 I/O 操作、网络通信、线程管理等。程序库可以通过 API 的形式暴露给应用程序使用，从而简化应用程序的编写和维护
   在设计和实现上，内核需要面对更多的底层硬件抽象和安全问题，因此需要更加高效和健壮；程序库则更关注提供高层次的抽象和易用性，因此需要更加灵活和易于扩展

可以看出，用户级线程和内核级线程都有各自的优点和缺点，在应用上主要表现为：
+ 用户级多线程对于处理逻辑并行性问题有很好的效果。但不擅长于解决物理并行问题
+ 内核级多线程适用于解决物理并行性问题

### 线程组合策略

由操作系统内核支持内核级多线程，由操作系统程序库来支持用户级多线程。用户级线程完全在用户空间创建，调度也是在应用程序内部进行，然后把用户级多线程映射到（或者说是绑定到）一些内核级多线程。**编程人员可以针对不同的应用特点调节内核级线程的数目来达到物理并行性和逻辑并行性的最佳方案**

#### 一对一

该模型为每个用户态的线程分配一个单独的内核态线程，在这种情况下，每个用户级线程都需要通过系统调用创建一个绑定的内核线程，并附加在上面执行。 这种模型允许所有线程并行执行，能够充分利用多核优势。目前Linux中的线程、OpenJDK Java线程等采用的都是一对一线程模型。每一个JVM线程，都有一个对应的内核线程

**优点**
+ 实现起来较为简单
+ 能够充分利用多核优势

**缺点**
+ 每创建一个用户线程，相应地就需要创建一个内核线程，开销较大，因此需要限制整个系统的线程数量
+ 用户级线程的切换会导致内核级线程的切换，进而引起用户态和内核态的频繁切换，开销较大

![](../../../../img/os/多线程策略-一对一.png)

#### 多对一

顾名思义，多对一线程模型中，多个用户线程对应到同一个内核线程上，线程的创建、调度、同步的所有细节全部由进程的用户空间线程库来处理。这样，极大地减少了创建内核态线程的成本，但是线程不可以并行。因此，这种模型现在基本上用的很少

**优点**
+ 用户线程的很多操作对内核来说都是透明的，不需要用户态和内核态的频繁切换。使线程的创建、调度、同步等非常快

**缺点**
+ 由于多个用户线程对应到同一个内核线程，如果其中一个用户线程阻塞，那么该程序内其他用户线程也无法执行
+ 无法利用内核调度算法，应用程序需要自己实现

![](../../../../img/os/多线程策略-多对一.png)

#### 多对多

这种模式下会为 n 个用户态线程分配 m 个内核态线程。m 通常小于 n（一种可行的策略是将 m 设置为核数）。这种多对多的关系，减少了内核线程，同时也保证了多核心并行。多对多模型中线程的调度需要由内核态和用户态一起来实现，例如线程间同步需要用户态和内核态共同实现。用户态和内核态的分工合作导致实现该模型非常复杂。Golang多线程模型所采用的就是多对多模型。Linux多线程模型曾经也想使用该模型，但它太复杂，要对内核进行大范围改动，所以还是采用了一对一的模型

**优点**
+ 能够利用多核CPU实现并行
+ 用户级线程切换大多数情况是在用户空间完成，不需要内核介入，减少了用户态和内核态切换带来的开销
+ 可使用的线程数量大幅增加

**缺点**
+ 实现起来非常复杂

![](../../../../img/os/多线程策略-多对多.png)

我们再回到文章开头的那个问题，为什么在Golang中创建大量的协程来执行并行任务，协程的创建、销毁、切换不会带来明显的性能开销？
很明显，Golang中的协程其实是用户级线程，而且采用了多对多的模型将协程映射到内核级线程，所以Golang即使创建成千上万的协程，也不会有太大的性能瓶颈。

再来看看Java线程池和Golang协程，其实它们有很多类似的地方：
+ Golang执行任务的内核级线程其实可以看作是Java线程池里的线程（只不过Java线程池里的用户级线程一一对应了一个内核级线程）
+ Golang中的协程其实可以看作是Java线程池中的任务，协程由Golang协程调度器来管理，Java线程池里的线程由线程池来管理（这样看来，Golang协程调度器是不是就类似于一个Java线程池）

这样一类比，是不是就容易理解多了！！！

## Golang协程调度

### GM模型

在Golang早期版本中，协程调度使用的是GM模型，其中G表示一个Goroutine，M表示一个内核线程，全局有一个协程队列用来存储全部的G

![](../../../../img/os/GM模型.png)

但是这种调度模型存在一些性能问题：
+ 当M想要执行一个G时，就会从全局队列中去取一个G，由于全局队列只有一个，而M有多个，所以每当M去获取G的时候，就会形成**激烈的锁竞争**
+ 当G中创建一个新的协程G‘时，为了运行G’，需要将G‘放入全局队列，再由空闲的M来执行。但是通常情况下，由G创建的G’和G是息息相关的，所以应尽可能的将G‘放在和执行G相同的M上来执行，这就造成了**很差的局部性**

### GMP模型

![](../../../../img/os/GMP模型.png)

再计算机的世界里有这么一句真理：**没有什么问题是加一个中间层不能解决的**。基于此，Golang在原有的GM模型上增加了一个调度器P，于是乎就有了现在的GMP模型。
再GMP模型中，每个P都会有一个本地队列用来存储G，最多存储256个G。线程M想要运行G，首先就要与P绑定，然后从P中取一个G来执行。如果P队列为空，那么M会尝试从全局队列拿一批G放入P，或者从其他P的本地队列中拿一半G放到与自己绑定的P的本地队列，然后再从P中取一个G来执行。
在新建G‘时，G’优先加入到P的本地队列，如果本地队列满了，则把P队列中一半的G移到全局队列中去，然后再将G‘加入P的本地队列

我们再来看看GMP模型是如何解决GM上述两个问题的：
首先是锁竞争，GMP模型通过增加P本地队列，使得每个M都是从不同的位置获取G，那么就在大多数情况下完全消除了锁竞争（只有在M所对应P的本地队列为空，需要去全局队列或其他P的本地队列中拿G时，才会有锁竞争）
其次是局部性，新创建的G’大多数情况下都会被加入到创建它的G所在P的本地队列中，这就从一定程度上解决了GM模型局部性差的问题

### Q&A

#### 为什么P的逻辑不直接加在M上

主要还是因为 M 其实是内核线程，内核只知道自己在跑线程，而 golang 的运行时（包括调度，垃圾回收等）其实都是用户空间里的逻辑。操作系统内核哪里还知道，也不需要知道用户空间的 golang 应用原来还有那么多花花肠子。这一切逻辑交给应用层自己去做就好，毕竟改内核线程的逻辑也不合适啊

> 参考
   [Golang的协程调度器原理及GMP设计思想](https://www.yuque.com/aceld/golang/srxd6d#7a8af6b1)
   [用户态线程和内核态线程的区别](https://www.cnblogs.com/FengZeng666/p/14219477.html)