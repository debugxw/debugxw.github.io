---
title: 红黑树
excerpt: 通过颜色标记来保持平衡的一种二叉搜索树，并且具有对数时间复杂度的插入、删除、查找操作
date: 2019-04-12 16:44:41
tags: 数据结构
image: /img/theme/019.jpg
---

## 一、概述
红黑树 (Red-Black Tree) 是一种特殊的二叉查找树，这意味着它满足二叉查找树的特征：任意一个节点的键值大于其左孩子的键值，且小于等于其右孩子的键值。除了具备二叉查找树的所有特性外，红黑树还包含了许多额外的信息。红黑树的每一个节点上都有一个存储位来表示节点的颜色信息，要么是红色，要么是黑色。一颗红黑树必定满足以下五个特征：
1. 每个节点要么是红色，要么是黑色
2. 根节点是黑色
3. 每个叶子节点的两个空节点是黑色的（后面称之为 NULL 节点）
4. 每个红色节点的两个子节点都是黑色的（根到每个叶子节点的所有路径上不能有两个连续的红色节点）
5. 对于任意一个节点而言，它到 NULL 节点的每一条路径上都包含相同数目的黑色节点

<center><img src="../../../../img/data_structure/rbt/rbt.png" width="60%" height="60%" /></center>

上图所示的红黑树的黑高 BH = 3。虽然红黑树不像 AVL 树一样，在高度上永远保持绝对的平衡，但是红黑树会保持相对平衡即 BH(left) == BH(right)，也就是说任意一个节点到叶子节点的最长路径不会超过最短路径长度的二倍（不包括最后的 NULL 节点）。
**定理：**有 N 个节点的红黑树，树的最大高度是 2log(N+1)。

## 二、插入
当向一颗红黑树中插入一个节点后，就有可能破坏红黑树的平衡，这时就需要做相应的调整，使得红黑树依旧满足上面所说的五个特性。插入一个节点时，首先按照平衡二叉树的插入规则将新节点添加到相应的位置，然后再进行调整。

首先我们想一下，新插入的节点应该是红色的还是黑色的呢？答案是红色。因为如果新插入的节点是黑色，则一定会违背上面的第五个特性，而如果新节点是红色的，则有可能违背第四个特性，也有可能不违背上面五个特性之中的任意一个，即插入新节点之后树还是平衡的。这就意味着我们调整时，如果新节点是红色的，我们处理的情况就会少一些。接下来，就是如何调整这棵树，努力使得它满足以上的五个特性，那么它就又重新变成了一颗正统的红黑树了！！！

为了方便讲述，进行如下规定（下图插入 X 后需要调整）：
+ 新插入的节点（当前节点）为 X，父节点为 P，祖父节点为 G，叔叔节点为 Y
+ A3 表示该子树的黑高 BH = 3，B3 表示该子树的黑高 BH = 3，C2 表示...

<center><img src="../../../../img/data_structure/rbt/rbt_ex.png" width="30%" height="30%" /></center>

### 1、无需调整
插入节点后，有两种情况无需调整：
+ X 为根节点，这时只需将根节点由红染黑即可。注意：如果在后续的回溯过程中 X 变为根节点，也属于这种情况
+ 父节点 P 为黑色，则当前树满足上面的所有特性，无需调整

### 2、需要调整
插入新节点后，有六种情况需要调整，而前三种和后三种是两两对称的：
+ P 为 G 的左子树：
  + a：Y 为红，X 可左可右；P、Y 变黑，G 变红，X 回溯至 G
  <center><img src="../../../../img/data_structure/rbt/rbt_a.png" width="60%" height="60%" /></center>
  + b：Y 为黑，X 为右子树；左旋 P，当前节点 X 变为 P（即把 P 当做新插入的节点），转化为 c（如果G 的右子树为空，即 Y 为空，那么 Y 就是空的黑色叶子节点）
  <center><img src="../../../../img/data_structure/rbt/rbt_b.png" width="60%" height="60%" /></center>
  + c：Y 为黑，X 为左子树；P 染黑，G 染红，右旋 G，结束
  <center><img src="../../../../img/data_structure/rbt/rbt_c.png" width="60%" height="60%" /></center>
+ P 为 G 的右子树：
  + d：Y 为红，X 可左可右；P、Y 变黑，G 变红，X 回溯至 G
  + e：Y 为黑，X 为左子树；右旋 P，当前节点 X 变为 P，转化为 f
  + f：Y 为黑，X 为右子树；P 染黑，G 染红，左旋 G，结束

可以看到，其实上面的 a 和 d 两种情况的调整操作是一样的，而这六种情况的核心思路都是：**将红色节点移动到根节点，然后将根节点染黑。**

### 3、构建红黑树
假设要插入的节点依次为 [12, 1, 9, 0, 3, 5, 4]，则构建红黑树的过程如下（这里省略了 NULL 节点）：

<center><img src="../../../../img/data_structure/rbt/rbt_insert.png" width="90%" height="90%" /></center>

#### AVL 插入 VS RBT 插入
+ 插入元素都是 BST 的插入，区别在于调整
+ 旋转次数：AVL 和 RBT 都是 O(1)
+ 指针回溯次数，最好：
  + 很早就遇到单旋或双旋的情况，为 O(1)
  + 很早就遇到 b、c 或者 e、f 的情况，为 O(1)
+ 指针回溯次数，最坏：
  + 回溯到根节点才发现平衡因子大于 1 或小于 -1，为 O(logN)
  + 不断执行 a 情况，直到根节点，**但每次向上回溯两层，**为 O(logN / 2)
+ 插入效率：RBT 略好于 AVL
+ 查询效率：AVL 略好于 RBT

## 三、删除
对于一棵普通的二叉排序树来说，删除的节点情况可以分为三种：
1. 待删除节点为叶子节点
2. 待删除节点只有左子树或只有右子树
3. 待删除节点既有左子树又有右子树

对于情况 3，要删除既有左子树又有右子树的节点，我们首先要找到该节点的先驱节点或后继节点，然后用先驱节点或后继节点替换该节点，最后按 1 或 2 中的方法删除后继节点即可。这样情况 3 就可以转换为情况 1 或 2。所以我们要删除的节点类型从大的方面来说，就只有两种。
同样，对于红黑树来说，我们要删除的节点类型大体来讲也只有两种。

### 1、待删节点只有左子树或只有右子树
假设待删除节点为 D，D 的父节点为 P，P 的另一个孩子节点为 S，S 的左右子树分别为 SL 和 SR。
在这种情况下，待删节点 D 不可能为红色（如果 D 为红色，那么一定会违背红黑树的特性 4 或 5，所以 D 只能为黑色）。D 为黑色那么只会出现以下两种情况：

<center><img src="../../../../img/data_structure/rbt/rbt_delete_1.png" width="60%" height="60%" /></center>

这两种情况的处理方式是一样的，即将 D 的左孩子或右孩子的颜色改成黑色，并用 D 的左孩子或右孩子替换 D，再将 D 删除即可（因为删除 D 以后，以 D 为根的子树上少了一个黑节点，所以要将 D 的孩子由红色变成黑色以保持红黑树的性质）。

### 2、待删除节点为叶子节点
**叶子节点为红色**
如果待删除节点为叶子节点且为红色，那么直接将该节点删除即可（因为删除一个红色叶子节点并不会违反红黑树的任何一个特性）。

**叶子节点为黑色**
这也是最复杂的一种情况，在调整的过程中，待删除节点 D 可能会向上回溯，回溯之后再看 D 是下面哪种情况进行调整，**直到 D 为红色或者 D 为根节点，这时，将刚开始的待删除节点删除，将此时 D 指向的节点染黑，调整结束**（即先进行调整，调整完成后，再来删除 D）。

**情况1-1**
D 是 P 的左孩子，且 S 为红色：**P 变成红色，S 变成黑色，左旋 P**（如下图，这里省略了 NULL 节点）。此时 D 的兄弟节点变成了黑色，就转变成了后面要讨论的几种情况。

<center><img src="../../../../img/data_structure/rbt/rbt_delete_2_1_1.png" width="60%" height="60%" /></center>

**情况1-2**
D 是 P 的右孩子，且 S 为红色：**P 变成红色，S 变成黑色，右旋 P。**此时 D 的兄弟节点变成了黑色，就转变成了后面要讨论的几种情况。（这种情况和情况1-1对称）

**情况2-1**
D 是 P 的左孩子，且 S 为黑色，SL、SR 都为黑色，P 红黑均可：**将 S 染红，D 回溯至 P**（如下图，在这个例子中，SL、SR 只能为 NULL 节点，D 回溯至 P 之后发现 P 为根节点，这时直接将 P 染黑，删除 D 即可。其中黄色代表红黑均可。）

<center><img src="../../../../img/data_structure/rbt/rbt_delete_2_2_1.png" width="60%" height="60%" /></center>

**情况2-2**
D 是 P 的右孩子，且 S 为黑色，SL、SR 都为黑色，P 红黑均可：**将 S 染红，D 回溯至 P**（这种情况和情况2-1对称）

**情况3-1**
D 是 P 的左孩子，且 S 为黑色，SL 为红色，SR 为黑色，P 红黑均可：**SL 染黑，S 染红，右旋 S**（这时就转换为了情况 4-1）。

<center><img src="../../../../img/data_structure/rbt/rbt_delete_2_3_1.png" width="60%" height="60%" /></center>

**情况3-2**
D 是 P 的右孩子，且 S 为黑色，SL 为黑色，SR 为红色，P 红黑均可：**LR 染黑，S 染红，左旋 S**（这时就转换为了情况 4-2，和情况3-1对称）。

**情况4-1**
D 是 P 的左孩子，且 S 为黑色，SR 为红色，SL 红黑均可（如果 SL 为黑色，那么一定为 NULL 节点）：**将 S 染为 P 的颜色，P 和 SR 染黑，左旋 P**，此时 D 回溯至根节点。（在下面这个例子中，指针回溯之后，发现指针指向根节点，这时直接将根节点 S 染为黑色，删除 D 即可）

<center><img src="../../../../img/data_structure/rbt/rbt_delete_2_4_1.png" width="60%" height="60%" /></center>

**情况4-2**
D 是 P 的右孩子，且 S 为黑色，SL 为红色，SR 红黑均可：**将 S 染为 P 的颜色，P 和 SL 染黑，左旋 P**，此时 D 回溯至根节点（和情况 4-1 对称）。

### 3、删除红黑树样例

<center><img src="../../../../img/data_structure/rbt/rbt_delete_3.png" width="90%" height="90%" /></center>

## 四、AVL 树和 RBT 树的应用
+ 红黑树
  + 广泛用于 c++ 的 STL 中，map 和 set 都是用红黑树实现的
  + 著名的 Linux 进程调度 Completely Fair Scheduler，用红黑树管理进程控制块，进程的虚拟内存区域都存储在一棵红黑树上，每个虚拟地址区域都对应一个红黑树节点，左指针指向相邻的低地址虚拟存储区域，右指针指向相邻的高地址虚拟地址空间
  + IO 多路复用 epoll 的实现采用红黑树组织管理 sockfd，以支持快速的增删改查
  + ngnix 中用红黑树管理 timer，因为红黑树是有序的，可以很快的得到距离当前最小的定时器
  + JDK1.8 中 TreeMap、HashMap、ConcurrentHashMap 的实现采用了红黑树
+ 虽然 AVL 树的查找效率很高，但由于维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多
  + Windows 对进程地址空间的管理用到了 AVL 树
  + Windows NT 内核中广泛存在

## 五、TreeMap 和 TreeSet

### TreeMap
TreeMap 是 java 中用来存储可排序键值对的一种容器，其内部使用的数据结构就是红黑树。每个红黑树节点存储一个 key-value 键值对，并根据 key 进行排序，排序的方式有两种：
+ 自然排序：此时，所有的 key 必须实现 Comparable 接口，用于比较两个 key 的大小
+ 定制排序：定义 TreeMap 时，新建一个 Comparator 对象，该对象用于比较任意两个 key 的大小

注意：如果使用自定义的类作为 TreeMap 中的 key 和 value，且想让 TreeMap 能够良好的工作，**则必须重写自定义类中的 equals 方法。**例如在 containsValue 中比较两个 value 是否相同就用到了 valEquals() 方法，而 valEquals() 方法则用到了对象的 equals 方法，源码如下：
```java
    public boolean containsValue(Object value) {
        for (Entry<K,V> e = getFirstEntry(); e != null; e = successor(e))
            if (valEquals(value, e.value))
                return true;
        return false;
    }
    
    static final boolean valEquals(Object o1, Object o2) {
        return (o1==null ? o2==null : o1.equals(o2));
    }
```

### TreeSet
TreeSet 是 java 中用来存储不能重复且有序的数据的一种容器。但在本质上，TreeSet 其实是用 TreeMap 来存储数据的。在 TreeSet 的源码中，有如下两个成员：
```java
    /**
     * The backing map.
     */
    private transient NavigableMap<E,Object> m;

    // Dummy value to associate with an Object in the backing Map
    private static final Object PRESENT = new Object();
```
这里的 NavigableMap 只是一个接口，但在构造 TreeSet 的时候会将 m 初始化为一个 TreeMap，这个 TreeMap 就是用来存储数据的容器。TreeSet 将所有的数据存储在 m 的 key 中，因为 TreeMap 中的 key 是唯一的且有序，所以也就达到了 TreeSet 存储不重复元素且有序的目的。在向 TreeSet 中添加一个元素时，实际上是调用了 TreeMap 的 put() 方法：
```java
    public boolean add(E e) {
        return m.put(e, PRESENT)==null;
    }
```
可以看到，在添加元素时，TreeSet 将元素作为 key 添加到 m 中，而 value 则放入一个 Object 常量（本质上 value 没什么卵用），也就是说 m 中存储的所有键值对的 key 都不相同，而 value 都相同。
TreeSet 中的其它方法，其实也都是直接调用了 TreeMap 中的方法，例如：
```java
    public boolean remove(Object o) {
        return m.remove(o)==PRESENT;
    }
    
    public boolean contains(Object o) {
        return m.containsKey(o);
    }
    
    public int size() {
        return m.size();
    }
```

## 六、源代码（java 实现）
由于本人太菜，写不出红黑树的代码，所以就把 TreeMap 中的部分源码给扣了下来。
```java
import java.util.Comparator;

public class RBTree<K, V> {

    private static final boolean RED = false;
    private static final boolean BLACK = true;

    private Entry<K, V> root;

    private final Comparator<? super K> comparator;

    public RBTree() {
        comparator = null;
    }

    public RBTree(Comparator<? super K> comparator) {
        this.comparator = comparator;
    }

    static final class Entry<K, V> {
        K key;
        V value;
        Entry<K, V> left;
        Entry<K, V> right;
        Entry<K, V> parent;
        boolean color = BLACK;

        Entry(K key, V value, Entry<K, V> parent) {
            this.key = key;
            this.value = value;
            this.parent = parent;
        }

        public K getKey() {
            return key;
        }

        public V getValue() {
            return value;
        }

        public V setValue(V value) {
            V oldValue = this.value;
            this.value = value;
            return oldValue;
        }

        public boolean equals(Object o) {
            if (!(o instanceof Entry))
                return false;
            Entry<?, ?> e = (Entry<?, ?>) o;

            return valEquals(key, e.getKey()) && valEquals(value, e.getValue());
        }

        public int hashCode() {
            int keyHash = (key == null ? 0 : key.hashCode());
            int valueHash = (value == null ? 0 : value.hashCode());
            return keyHash ^ valueHash;
        }

        public String toString() {
            return key + "=" + value;
        }
    }

    static final boolean valEquals(Object o1, Object o2) {
        return (o1 == null ? o2 == null : o1.equals(o2));
    }

    public V put(K key, V value) {
        Entry<K, V> t = root;
        if (t == null) {
            root = new Entry<>(key, value, null);
            return null;
        }
        int cmp;
        Entry<K, V> parent;
        // split comparator and comparable paths
        Comparator<? super K> cpr = comparator;
        if (cpr != null) {
            do {
                parent = t;
                cmp = cpr.compare(key, t.key);
                if (cmp < 0)
                    t = t.left;
                else if (cmp > 0)
                    t = t.right;
                else
                    return t.setValue(value);
            } while (t != null);
        } else {
            if (key == null)
                throw new NullPointerException();
            @SuppressWarnings("unchecked")
            Comparable<? super K> k = (Comparable<? super K>) key;
            do {
                parent = t;
                cmp = k.compareTo(t.key);
                if (cmp < 0)
                    t = t.left;
                else if (cmp > 0)
                    t = t.right;
                else
                    return t.setValue(value);
            } while (t != null);
        }
        Entry<K, V> e = new Entry<>(key, value, parent);
        if (cmp < 0)
            parent.left = e;
        else
            parent.right = e;
        fixAfterInsertion(e);
        return null;
    }

    private void fixAfterInsertion(Entry<K, V> x) {
        x.color = RED;

        while (x != null && x != root && x.parent.color == RED) {
            if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {
                Entry<K, V> y = rightOf(parentOf(parentOf(x)));
                if (colorOf(y) == RED) {
                    setColor(parentOf(x), BLACK);
                    setColor(y, BLACK);
                    setColor(parentOf(parentOf(x)), RED);
                    x = parentOf(parentOf(x));
                } else {
                    if (x == rightOf(parentOf(x))) {
                        x = parentOf(x);
                        rotateLeft(x);
                    }
                    setColor(parentOf(x), BLACK);
                    setColor(parentOf(parentOf(x)), RED);
                    rotateRight(parentOf(parentOf(x)));
                }
            } else {
                Entry<K, V> y = leftOf(parentOf(parentOf(x)));
                if (colorOf(y) == RED) {
                    setColor(parentOf(x), BLACK);
                    setColor(y, BLACK);
                    setColor(parentOf(parentOf(x)), RED);
                    x = parentOf(parentOf(x));
                } else {
                    if (x == leftOf(parentOf(x))) {
                        x = parentOf(x);
                        rotateRight(x);
                    }
                    setColor(parentOf(x), BLACK);
                    setColor(parentOf(parentOf(x)), RED);
                    rotateLeft(parentOf(parentOf(x)));
                }
            }
        }
        root.color = BLACK;
    }

    private static <K, V> boolean colorOf(Entry<K, V> p) {
        return (p == null ? BLACK : p.color);
    }

    private static <K, V> Entry<K, V> parentOf(Entry<K, V> p) {
        return (p == null ? null : p.parent);
    }

    private static <K, V> void setColor(Entry<K, V> p, boolean c) {
        if (p != null)
            p.color = c;
    }

    private static <K, V> Entry<K, V> leftOf(Entry<K, V> p) {
        return (p == null) ? null : p.left;
    }

    private static <K, V> Entry<K, V> rightOf(Entry<K, V> p) {
        return (p == null) ? null : p.right;
    }

    private void rotateLeft(Entry<K, V> p) {
        if (p != null) {
            Entry<K, V> r = p.right;
            p.right = r.left;
            if (r.left != null)
                r.left.parent = p;
            r.parent = p.parent;
            if (p.parent == null)
                root = r;
            else if (p.parent.left == p)
                p.parent.left = r;
            else
                p.parent.right = r;
            r.left = p;
            p.parent = r;
        }
    }

    private void rotateRight(Entry<K, V> p) {
        if (p != null) {
            Entry<K, V> l = p.left;
            p.left = l.right;
            if (l.right != null) l.right.parent = p;
            l.parent = p.parent;
            if (p.parent == null)
                root = l;
            else if (p.parent.right == p)
                p.parent.right = l;
            else p.parent.left = l;
            l.right = p;
            p.parent = l;
        }
    }

    public V remove(Object key) {
        Entry<K, V> p = getEntry(key);
        if (p == null)
            return null;

        V oldValue = p.value;
        deleteEntry(p);
        return oldValue;
    }

    final Entry<K, V> getEntry(Object key) {
        // Offload comparator-based version for sake of performance
        if (comparator != null)
            return getEntryUsingComparator(key);
        if (key == null)
            throw new NullPointerException();
        @SuppressWarnings("unchecked")
        Comparable<? super K> k = (Comparable<? super K>) key;
        Entry<K, V> p = root;
        while (p != null) {
            int cmp = k.compareTo(p.key);
            if (cmp < 0)
                p = p.left;
            else if (cmp > 0)
                p = p.right;
            else
                return p;
        }
        return null;
    }

    final Entry<K, V> getEntryUsingComparator(Object key) {
        @SuppressWarnings("unchecked")
        K k = (K) key;
        Comparator<? super K> cpr = comparator;
        if (cpr != null) {
            Entry<K, V> p = root;
            while (p != null) {
                int cmp = cpr.compare(k, p.key);
                if (cmp < 0)
                    p = p.left;
                else if (cmp > 0)
                    p = p.right;
                else
                    return p;
            }
        }
        return null;
    }

    private void deleteEntry(Entry<K, V> p) {
        // 找到直接后继节点
        if (p.left != null && p.right != null) {
            Entry<K, V> s = successor(p);
            p.key = s.key;
            p.value = s.value;
            p = s;
        }

        // Start fixup at replacement node, if it exists.
        Entry<K, V> replacement = (p.left != null ? p.left : p.right);

        // 只有一个叶子节点的情况
        if (replacement != null) {
            // Link replacement to parent
            replacement.parent = p.parent;
            if (p.parent == null)
                root = replacement;
            else if (p == p.parent.left)
                p.parent.left = replacement;
            else
                p.parent.right = replacement;

            // Null out links so they are OK to use by fixAfterDeletion.
            p.left = p.right = p.parent = null;

            // 待删除节点为黑色，且只有一个红色孩子节点
            if (p.color == BLACK)
                fixAfterDeletion(replacement);
        } else if (p.parent == null) { // 只有根节点，直接删除
            root = null;
        } else { // 删除叶子节点
            if (p.color == BLACK)
                fixAfterDeletion(p);

            if (p.parent != null) {
                if (p == p.parent.left)
                    p.parent.left = null;
                else if (p == p.parent.right)
                    p.parent.right = null;
                p.parent = null;
            }
        }
    }

    static <K, V> Entry<K, V> successor(Entry<K, V> t) {
        if (t == null)
            return null;
        else if (t.right != null) {
            Entry<K, V> p = t.right;
            while (p.left != null)
                p = p.left;
            return p;
        } else {
            Entry<K, V> p = t.parent;
            Entry<K, V> ch = t;
            while (p != null && ch == p.right) {
                ch = p;
                p = p.parent;
            }
            return p;
        }
    }

    private void fixAfterDeletion(Entry<K, V> x) {
        while (x != root && colorOf(x) == BLACK) {
            if (x == leftOf(parentOf(x))) {
                Entry<K, V> sib = rightOf(parentOf(x));

                // 情况 1-1
                if (colorOf(sib) == RED) {
                    setColor(sib, BLACK);
                    setColor(parentOf(x), RED);
                    rotateLeft(parentOf(x));
                    sib = rightOf(parentOf(x));
                }

                // 情况 2-1
                if (colorOf(leftOf(sib)) == BLACK &&
                    colorOf(rightOf(sib)) == BLACK) {
                    setColor(sib, RED);
                    x = parentOf(x);
                } else {
                    // 情况 3-1
                    if (colorOf(rightOf(sib)) == BLACK) {
                        setColor(leftOf(sib), BLACK);
                        setColor(sib, RED);
                        rotateRight(sib);
                        sib = rightOf(parentOf(x));
                    }
                    // 情况 4-1
                    setColor(sib, colorOf(parentOf(x)));
                    setColor(parentOf(x), BLACK);
                    setColor(rightOf(sib), BLACK);
                    rotateLeft(parentOf(x));
                    x = root;
                }
            } else { // 和上面对称
                Entry<K, V> sib = leftOf(parentOf(x));

                if (colorOf(sib) == RED) {
                    setColor(sib, BLACK);
                    setColor(parentOf(x), RED);
                    rotateRight(parentOf(x));
                    sib = leftOf(parentOf(x));
                }

                if (colorOf(rightOf(sib)) == BLACK &&
                    colorOf(leftOf(sib)) == BLACK) {
                    setColor(sib, RED);
                    x = parentOf(x);
                } else {
                    if (colorOf(leftOf(sib)) == BLACK) {
                        setColor(rightOf(sib), BLACK);
                        setColor(sib, RED);
                        rotateLeft(sib);
                        sib = leftOf(parentOf(x));
                    }
                    setColor(sib, colorOf(parentOf(x)));
                    setColor(parentOf(x), BLACK);
                    setColor(leftOf(sib), BLACK);
                    rotateRight(parentOf(x));
                    x = root;
                }
            }
        }

        setColor(x, BLACK);
    }

    final Entry<K,V> getFirstEntry() {
        Entry<K,V> p = root;
        if (p != null)
            while (p.left != null)
                p = p.left;
        return p;
    }

    public boolean containsValue(Object value) {
        for (Entry<K,V> e = getFirstEntry(); e != null; e = successor(e)) {
            if (valEquals(value, e.value))
                return true;
        }
        return false;
    }
}
```

> 参考：
  [JDK源码剖析之红黑树TreeMap](https://www.bilibili.com/video/av23890827/?p=10)
  [红黑树之删除节点](https://www.cnblogs.com/qingergege/p/7351659.html)
