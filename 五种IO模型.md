---
title: 五种 I/O 模型
excerpt: 计算机系统中描述输入输出操作的方式和效率的抽象模型
date: 2019-07-12 15:35:08
tags: 操作系统
image: /img/theme/011.jpg
---

### 一、基本概念

#### 1、同步、异步
**同步和异步关注的是消息通信机制** (synchronous communication / asynchronous communication)
**同步**：就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。
**异步**：和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。

#### 2、阻塞、非阻塞
**阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态**。
**阻塞**：阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。
**非阻塞**：和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。

可以简单地理解为：**阻塞、非阻塞说的是调用者。同步、异步说的是被调用者。**

#### 3、阻塞IO、非阻塞IO

**缓存IO**
缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中， 操作系统会将 I/O 的数据缓存在文件系统的页缓存中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。
缓存 I/O 的缺点是数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。

例如当用户线程对一个文本发起 I/O 请求操作时，内核会先去查看要读取的数据是否就绪（是否已存在于操作系统内核），对于阻塞 I/O 来说，如果数据没有就绪，则会一直在那等待，直到数据就绪；对于非阻塞 I/O 来说，如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读取的数据没有就绪。当数据就绪之后，再来将数据拷贝到用户线程，这样才完成了一个完整的 I/O 读请求操作，也就是说一个完整的 I/O 读请求操作主要包括两个阶段：
**阶段一：**查看数据是否就绪
**阶段二：**将数据由内核拷贝到用户进程

那么阻塞（blocking I/O）和非阻塞（non-blocking I/O）的区别就在于第一个阶段，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。
Java 中传统的 I/O 都是阻塞 I/O，比如通过 socket 来读数据，调用 read() 方法之后，如果数据没有就绪，当前线程就会一直阻塞在 read 方法调用那里，直到有数据才返回；而如果是非阻塞 I/O 的话，当数据没有就绪，read() 方法应该返回一个标志信息，告知当前线程数据没有就绪，而不是一直在那里等待。

#### 4、同步IO、异步IO
在《Unix 网络编程》一书中对同步 I/O 和异步 I/O 的定义是这样的：
A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes.
An asynchronous I/O operation does not cause the requesting process to be blocked.
从字面意思理解：同步 I/O，即如果一个线程请求进行 I/O 操作，在 I/O 操作完成之前，该线程会被阻塞。而异步 I/O 为，如果一个线程请求进行 I/O 操作，I/O 操作不会导致请求线程被阻塞。

事实上，同步 I/O 和异步 I/O 模型是针对用户线程和内核的交互来说的：
对于同步 I/O：当用户发出 I/O 请求操作之后，如果数据没有就绪，需要通过用户线程或者内核不断地去轮询数据是否就绪，当数据就绪时，再将数据从内核拷贝到用户线程；
而异步 I/O：只有 I/O 请求操作的发出是由用户线程来进行的，I/O 操作的两个阶段都是由内核自动完成，然后发送通知告知用户线程 I/O 操作已经完成。也就是说在异步 I/O 中，不会对用户线程产生任何阻塞。

### 二、Linux下的五种IO模型

#### 1、阻塞IO
在 linux 中，默认情况下所有的 socket 都是 blocking，一个典型的读操作流程大概是这样：
**第一步：**等待数据从网络中到达，当所有等待数据到达时，它被复制到内核中的某个缓冲区。
**第二步：**把数据从内核缓冲区复制到应用程序缓冲区。

<center><img src="../../../../img/os/blockingIO.png" width="80%" height="80%" /></center>

当用户进程调用了 recvfrom 这个系统调用，kernel 就开始了 I/O 的第一个阶段：准备数据。对于 network I/O 来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的 UDP 包），这个时候 kernel 就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当 kernel 一直等到数据准备好了，它就会将数据从 kernel 中拷贝到用户内存，然后 kernel 返回结果，用户进程才解除 block 的状态，重新运行起来。<font color="#cc0000">**所以，blocking I/O 的特点就是在 I/O 执行的两个阶段都被阻塞了。**</font>

#### 2、非阻塞式IO
linux 下，可以通过设置 socket 使其变为 non-blocking。当对一个 non-blocking socket 执行读操作时，流程是这个样子：

<center><img src="../../../../img/os/non-blockingIO.png" width="80%" height="80%" /></center>

从图中可以看出，当用户进程发出 read 操作时，如果 kernel 中的数据还没有准备好，那么它并不会 block 用户进程，而是立刻返回一个 error。从用户进程角度讲，它发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦 kernel 中的数据准备好了，并且又再次收到了用户进程的 system call，那么它马上就将数据拷贝到了用户内存，然后返回。<font color="#cc0000">**所以，用户进程第一个阶段不是阻塞的,需要不断的主动询问 kernel 数据好了没有；第二个阶段依然总是阻塞的。**</font>

#### 3、IO多路复用
I/O 多路复用模型 (I/O multiplexing Model)，是目前使用得比较多的模型。Java NIO 实际上就是多路复用 I/O。目前支持 I/O 多路复用的系统调用有 select、pselect、poll、epoll，I/O 多路复用就是通过一种机制，一个进程可以监视多个 socket，一旦某个 socket 就绪，能够通知程序进行相应的读写操作。 但 select、pselect、poll、epoll 本质上都是同步 I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步 I/O 则无需自己负责进行读写，异步 I/O 的实现会负责把数据从内核拷贝到用户空间  。
**I/O 多路复用同非阻塞 I/O 本质一样，不过利用了新的 select 系统调用，由内核来负责本来是请求进程该做的轮询操作。看似比非阻塞 I/O 还多了一个系统调用开销，不过因为可以支持多路 I/O，才算提高了效率。**它的基本原理就是 select / epoll 这个 function 会不断的轮询所负责的所有 socket，当某个 socket 有数据到达了，就通知用户进程。它的流程如图：

<center><img src="../../../../img/os/IOmultiplexing.png" width="80%" height="80%" /></center>

当用户进程调用了 select，那么整个进程会被 block，而同时，kernel 会监视所有 select 负责的 socket，当任何一个 socket 中的数据准备好了，select 就会返回。这个时候用户进程再调用 read 操作，将数据从 kernel 拷贝到用户进程。这个图和 blocking I/O 的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个 system call (select 和 recvfrom)，而 blocking I/O 只调用了一个 system call (recvfrom)。但是，用 select 的优势在于它可以同时处理多个 connection。**所以，如果处理的连接数不是很高的话，使用 I/O 多路复用的 web server 不一定比使用多线程 + 阻塞 I/O 的 web server 性能更好，可能延迟还更大。**

**select / epoll 的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。**
在 I/O multiplexing Model 中，实际中，对于每一个 socket，一般都设置成为 non-blocking，但是，如上图所示，整个用户的 process 其实是一直被 block 的。只不过 process 是被 select 这个函数 block，而不是被 socket I/O 给 block。

#### 4、信号驱动IO
用的很少，直接上图：

<center><img src="../../../../img/os/SignalDrivenIO.png" width="80%" height="80%" /></center>

在信号驱动 I/O 模型中，当用户线程发起一个 I/O 请求操作，会给对应的 socket 注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用 I/O 读写操作来进行实际的 I/O 请求操作。

#### 5、异步IO
异步 I/O 模型才是最理想的 I/O 模型，它的工作机制是告知内核启动某个操作，并让内核在整个操作（包括将数据从内核拷贝到用户空间）完成后通知我们。如图：

<center><img src="../../../../img/os/asynchronousIO.png" width="80%" height="80%" /></center>

用户进程发起 read 操作之后，立刻就可以开始去做其它的事。而另一方面，从 kernel 的角度，当它受到一个 asynchronous read 之后，首先它会立刻返回，所以不会对用户进程产生任何 block。然后，kernel 会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都 完成之后，kernel 会给用户进程发送一个 signal，告诉它 read 操作完成了。在这整个过程中，进程完全没有被 block。异步 I/O 是需要操作系统的底层支持，在 Java 7 中，提供了 Asynchronous IO。

**总结**
其实前四种 I/O 模型都是同步 I/O 操作，他们的区别在于第一阶段，而他们的第二阶段是一样的：在数据从内核复制到应用缓冲区期间（用户空间），进程阻塞于 recvfrom 调用。

### 三、两种高性能IO设计模式

在传统的网络服务设计模式中，有两种比较经典的模式：一种是多线程，一种是线程池。对于多线程模式，也就说来了 client，服务器就会新建一个线程来处理该 client 的读写事件，如下图所示：

<center><img src="../../../../img/os/multithreading.png" width="50%" height="50%" /></center>

这种模式虽然处理起来简单方便，但是由于服务器为每个 client 的连接都采用一个线程去处理，使得资源占用非常大。因此，当连接数量达到上限时，再有用户请求连接，直接会导致资源瓶颈，严重的可能会直接导致服务器崩溃。

因此，为了解决这种一个线程对应一个客户端模式带来的问题，提出了采用线程池的方式，也就说创建一个固定大小的线程池，来一个客户端，就从线程池取一个空闲线程来处理，当客户端处理完读写操作之后，就交出对线程的占用。因此这样就避免为每一个客户端都要创建线程带来的资源浪费，使得线程可以重用。
但是线程池也有它的弊端，如果连接大多是长连接，因此可能会导致在一段时间内，线程池中的线程都被占用，那么当再有用户请求连接时，由于没有可用的空闲线程来处理，就会导致客户端连接失败，从而影响用户体验。**因此，线程池比较适合大量的短连接应用。**

因此便出现了下面的两种高性能 I/O 设计模式：Reactor 和 Proactor。
在 Reactor 模式中，会先对每个 client 注册感兴趣的事件，然后有一个线程专门去轮询每个 client 是否有事件发生，当有事件发生时，便顺序处理每个事件，当所有事件处理完之后，便再转去继续轮询，如下图所示：

<center><img src="../../../../img/os/reactorIOModel.png" width="65%" height="65%" /></center>

从这里可以看出，**Reactor 的核心思想就是 I/O 多路复用**。注意，上面的图中展示的是顺序处理每个事件，当然为了提高事件处理速度，可以通过多线程或者线程池的方式来处理事件。

而在 Proactor 模式中，当检测到有事件发生时，会新起一个异步操作，然后交由内核线程去处理，当内核线程完成 I/O 操作之后，发送一个通知告知操作已完成。可以得知，**Proactor 的使用的是异步 I/O 模型**

### 四、应用

#### Redis IO 模型

Redis作为一个高性能键值存储系统，在硬件设备较好的情况下，单机QPS甚至能达到10W+。我们知道，Redis是使用单线程来处理客户端的读写请求的，但是为什么单线程能达到如此高的性能呢？主要有如下几个原因：

1. 所有的读写操作均基于内存
2. 单线程避免了资源竞争和线程切换带来的开销
3. 高效的数据结构
4. <font color="red">非阻塞IO+多路复用</font>

**为什么Redis不使用异步IO，而是IO多路复用？**

异步IO在Linux系统目前为止还不成熟，多路复用是同步IO和异步IO之间的一种折衷方案，并且多路复用模型已经能很大程度上解决并发编程问题

####

> 参考：
    [Java NIO：浅析 I/O 模型](https://www.cnblogs.com/dolphin0520/p/3916526.html)
    [Unix 五种 I/O 模型](http://www.tianshouzhi.com/api/tutorials/netty/221)
    [聊聊 Java 中的几种 I/O 模型](https://www.xncoding.com/2018/04/02/java/io.html)
    [Java NIO浅析](https://tech.meituan.com/2016/11/04/nio.html)