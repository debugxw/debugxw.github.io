---
title: 单例模式
excerpt: 它是一个稳定的锚点，让你能够在变幻莫测的环境中保持平衡和清晰的头脑
date: 2019-04-15 19:19:22
tags: 设计模式
image: /img/theme/008.jpg
---

单例模式 (SingletonPattern) 是指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点。单例模式是创建型模式。单例模式在现实生活中应用也非常广泛。例如，国家主席、公司 CEO、部门经理等。在 J2EE 标准中，ServletContext、ServletContextConfig 等；在 Spring 框架应用中 ApplicationContext、数据库的连接池也都是单例形式。

## 一、实现方式

### 饿汉式单例

```java
public class HungrySingleton {

    private static final HungrySingleton instance = new HungrySingleton();

    private HungrySingleton() {}

    public static HungrySingleton getInstance() {
        return instance;
    }
}
```
饿汉式单例在类加载的时候就进行初始化，并且创建单例对象，而且线程绝对安全。
**优点：**没有加任何的锁，执行效率比较高
**缺点：**类加载的时候就初始化，不管有没有用到都会存在，浪费了内存
饿汉式单例适用于单例对象较少的情况。Spring 中 IOC 容器 ApplicationContext 就是典型的饿汉式单例

### 懒汉式单例

```java
public class LazySingleton {

    private static LazySingleton instance = null;

    private LazySingleton() {}

    public synchronized static LazySingleton getInstance() {
        if (instance == null)
            instance = new LazySingleton();
        return instance;
    }
}
```
懒汉式单例的特点是：被外部类调用的时候，类才会初始化并创建对象，而且 synchronized 关键字保证了线程安全。这很好的解决了饿汉式单例浪费内存的问题，但是，因为是用 synchronized 加锁，所以在线程数量比较多情况下，如果CPU分配压力上升，会导致大批量线程出现阻塞，从而导致程序运行性能大幅下降

### 双重检查锁单例

```java
public class DoubleCheckSingleton {

    private static volatile DoubleCheckSingleton instance = null;

    private DoubleCheckSingleton() {}

    public static DoubleCheckSingleton getInstance() {
        if (instance == null) {
            synchronized (DoubleCheckSingleton.class) {
                if (instance == null) {
                    instance = new DoubleCheckSingleton();
                }
            }
        }
        return instance;
    }
}
```
**为什么要将 instance 声明为 volatile？**
+ 保证可见性：线程 A 在自己的工作线程内创建了实例，但此时还未同步到主存中；此时线程 B 在主存中判断 instance 还是 null，那么线程 B 又将在自己的工作线程中创建一个实例，这样就创建了多个实例。但是因为 synchronized 关键字能同时保证原子性和可见性，同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中，保证当其他线程再进入的时候，在主存中读取到的就是最新的变量内容了。所以这并不是一定要使用 volatile 关键字的原因。
+ **禁止指令重排序：**我们知道 new Singleton() 是一个非原子操作，编译器可能会对指令重排序（构造函数可能在整个对象初始化完成前执行完毕，即赋值操作（只是在内存中开辟一片存储区域后直接返回内存的引用）在初始化对象前完成）。而线程 B 在线程 A 赋值完时判断 instance 就不为 null 了，此时 B 拿到的将是一个没有初始化完成的半成品。

双检锁单例模式相对于懒汉式单例在性能上有了一定的提升，双检锁单例的阻塞并不像懒汉单例那样是基于整个 LazySingleton 类的阻塞，而是在 getInstance() 方法内部阻塞，只要逻辑不是太复杂，对于调用者而言感知不到。但是，用到了 synchronized 关键字，总归是要上锁，对程序性能还是存在一定影响的。难道就没有一种更好的方式，既兼顾饿汉式的内存浪费，又兼顾 synchronized 的性能问题？当然是有的，那就是使用静态内部类的方式实现单例

### 静态内部类单例模式

```java
public class StaticInnerSingleton {

    private StaticInnerSingleton() {}

    public static StaticInnerSingleton getInstance() {
        return SingletonHolder.instance;
    }

    /* 默认不加载，用到时才加载 */
    private static class SingletonHolder {
        private static final StaticInnerSingleton instance = new StaticInnerSingleton();
    }
}
```
这种形式兼顾饿汉式的内存浪费，也兼顾 synchronized 性能问题。内部类一定是要在方法调用之前初始化，巧妙地避免了线程安全问题

## 二、反射破坏单例

上面介绍的单例模式的构造方法除了加上 private 以外，没有做任何处理。如果我们使用反射来调用其构造方法，然后，再调用 getInstance() 方法，应该就会两个不同的实例。例如下面的测试用例：

```java
public class Test {

    public static void main(String[] args) {
        try {
            Class<?> clazz = StaticInnerSingleton.class;
            Constructor<?> constructor = clazz.getDeclaredConstructor();

            constructor.setAccessible(true);
            Object object1 = constructor.newInstance();
            Object object2 = StaticInnerSingleton.getInstance();

            System.out.println(object1 == object2);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```
如果运行上面的程序，会输出 false，那么这里显然创建了两个不同的实例，这就违背了单例模式的初衷。为了避免这种情况，我们可以在其构造方法中做一些限制，一旦出现多次创建实例，则直接抛出异常。优化后的代码如下：
```java
public class StaticInnerSingleton {

    private StaticInnerSingleton() {
        if (SingletonHolder.instance != null) {
            throw new RuntimeException("不允许创建多个实例！");
        }
    }

    public static StaticInnerSingleton getInstance() {
        return SingletonHolder.instance;
    }

    /* 默认不加载，用到时才加载 */
    private static class SingletonHolder {
        private static final StaticInnerSingleton instance = new StaticInnerSingleton();
    }
}
```

## 三、序列化破坏单例

当我们将一个单例对象创建好，有时候需要将对象序列化然后写入到磁盘，下次使用时再从磁盘中读取到对象，反序列化转化为内存对象。反序列化后的对象会重新分配内存，即重新创建。那如果序列化的目标的对象为单例对象，就违背了单例模式的初衷，相当于破坏了单例。修改 StaticInnerSingleton 使之实现 Serializable 接口，并进行序列化测试：

```java
import java.io.Serializable;

public class StaticInnerSingleton implements Serializable {

    private static final long serialVersionUID = 12345L;

    private StaticInnerSingleton() {
        if (SingletonHolder.instance != null) {
            throw new RuntimeException("不允许创建多个实例！");
        }
    }

    public static StaticInnerSingleton getInstance() {
        return SingletonHolder.instance;
    }

    /* 默认不加载，用到时才加载 */
    private static class SingletonHolder {
        private static final StaticInnerSingleton instance = new StaticInnerSingleton();
    }
}
```
```java
public class Test {

    public static void main(String[] args) {
        StaticInnerSingleton s1 = null;
        StaticInnerSingleton s2 = StaticInnerSingleton.getInstance();

        try (FileOutputStream fos = new FileOutputStream("instance");
             ObjectOutputStream oos = new ObjectOutputStream(fos);
             FileInputStream fis = new FileInputStream("instance");
             ObjectInputStream ois = new ObjectInputStream(fis)) {

            oos.writeObject(s2);
            oos.flush();

            s1 = (StaticInnerSingleton) ois.readObject();

            System.out.println(s1 == s2);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```
运行程序会发现输出结果为 false，可以看出，反序列化后的对象和手动创建的对象是不一致的，违背了单例的设计初衷。那么，我们如何保证序列化的情况下也能够实现单例？其实很简单，只需要增加readResolve()方法即可。
```java
import java.io.Serializable;

public class StaticInnerSingleton implements Serializable {

    private static final long serialVersionUID = 12345L;

    private StaticInnerSingleton() {
        if (SingletonHolder.instance != null) {
            throw new RuntimeException("不允许创建多个实例！");
        }
    }

    public static StaticInnerSingleton getInstance() {
        return SingletonHolder.instance;
    }

    /* 默认不加载，用到时才加载 */
    private static class SingletonHolder {
        private static final StaticInnerSingleton instance = new StaticInnerSingleton();
    }

    private Object readResolve() {
        return SingletonHolder.instance;
    }
}
```
再次测试发现程序输出结果变为了 true。那是不是就意味着单例对象在内存中只存在一个呢？并不是。实际上，在反序列化时会在内存中重新分配空间并创建对象，只不过新创建的对象没有被返回而已，返回的是 readResolve() 方法中原来的单例对象（具体可参考 JDK 源码 中的 ObjectInputStream.readObject() 方法）。那么如果创建对象的动作发生频率增大，就意味着内存分配开销也就随之增大，难道真的就没办法从根本上解决问题吗？注册式单例也许能帮助到你。

## 四、注册式单例

### 枚举方式

```java
public enum  EnumSingleton {
    INSTANCE;

    public static EnumSingleton getInstance() {
        return INSTANCE;
    }
}
```
使用反编译工具对 EnumSingle.class 进行反编译得到如下代码：
```java
public final class EnumSingleton extends Enum
{

    public static EnumSingleton[] values()
    {
        return (EnumSingleton[])$VALUES.clone();
    }

    public static EnumSingleton valueOf(String name)
    {
        return (EnumSingleton)Enum.valueOf(com/designmode/singleton/EnumSingleton, name);
    }

    private EnumSingleton(String s, int i)
    {
        super(s, i);
    }

    public static EnumSingleton getInstance()
    {
        return INSTANCE;
    }

    public static final EnumSingleton INSTANCE;
    private static final EnumSingleton $VALUES[];

    static 
    {
        INSTANCE = new EnumSingleton("INSTANCE", 0);
        $VALUES = (new EnumSingleton[] {
            INSTANCE
        });
    }
}
```
可以看到枚举式单例在 static 静态代码块中就对 INSTANCE 进行了赋值，使用饿汉式实现。那么反射是否可以破坏单例呢？编写如下代码进行测试：
```java
public static void main(String[] args) {
    try {
        Class<?> clazz = EnumSingleton.class;
        EnumSingleton instance = (EnumSingleton) clazz.newInstance();
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```
运行程序会发现程序抛出了异常：这是因为使用 Class.newInstance() 方法只能获得类的默认无参构造方法，且该方法对当前类可见。而 EnumSingleton 的构造方法是 private 权限，所以无法通过这种方式获得创建新的对象。既然从反编译的代码中了解到 EnumSingleton 的构造方法为 private 且有两个参数，那么可以用 Constructor.newInstance() 方法获得吗？编写如下代码进行测试：
```java
public static void main(String[] args) {
    try {
        Class<?> clazz = EnumSingleton.class;
        Constructor c = clazz.getDeclaredConstructor(String.class, int.class);
        c.setAccessible(true);
        EnumSingleton instance = (EnumSingleton) c.newInstance("igeen", 0);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```
运行程序会发现程序还是抛出了异常：这是因为在 Constructor.newInstance() 方法中做了强制性判断，如果修饰符是 Modifier.ENUM 枚举类型，直接抛出异常。如下：
```java
@CallerSensitive
public T newInstance(Object ... initargs)
    throws InstantiationException, IllegalAccessException,
           IllegalArgumentException, InvocationTargetException
{
    if (!override) {
        if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {
            Class<?> caller = Reflection.getCallerClass();
            checkAccess(caller, clazz, null, modifiers);
        }
    }
    if ((clazz.getModifiers() & Modifier.ENUM) != 0)
        throw new IllegalArgumentException("Cannot reflectively create enum objects");
    ConstructorAccessor ca = constructorAccessor;   // read volatile
    if (ca == null) {
        ca = acquireConstructorAccessor();
    }
    @SuppressWarnings("unchecked")
    T inst = (T) ca.newInstance(initargs);
    return inst;
}
```
到此，我们可以知道，反射无法破坏枚举式单例，那么序列化能否破坏呢？编写如下测试程序：
```java
public static void main(String[] args) {
    try (FileOutputStream fos = new FileOutputStream("instance");
        ObjectOutputStream oos = new ObjectOutputStream(fos);
        FileInputStream fis = new FileInputStream("instance");
        ObjectInputStream ois = new ObjectInputStream(fis)) {

        EnumSingleton i1 = null;
        EnumSingleton i2 = EnumSingleton.getInstance();
        oos.writeObject(i2);
        oos.flush();
        i1 = (EnumSingleton) ois.readObject();

        System.out.println(i1 == i2);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```
运行程序会发现输出结果为 true：如果查看 ObjectInputStream.readObject() 源码可以发现方法在执行的过程中有如下代码片段：
```java
...
try {
    @SuppressWarnings("unchecked")
    Enum<?> en = Enum.valueOf((Class)cl, name);
    result = en;
} catch (IllegalArgumentException ex) {
    throw (IOException) new InvalidObjectException(
        "enum constant " + name + " does not exist in " +
        cl).initCause(ex);
}
...
```
大致可以看出，枚举类型其实是通过类名和 Class 对象类找到一个唯一的枚举对象。因此，枚举对象不可能被类加载器加载多次。（Java 规范中规定，每一个枚举类型及其定义的枚举变量在 JVM 中都是唯一的，因此在枚举类型的序列化和反序列化上，Java 做了特殊的规定。在序列化的时候 Java 仅仅是将枚举对象的 name 属性输出到结果中，反序列化的时候则是通过 java.lang.Enum 的 valueOf() 方法来根据名字查找枚举对象）

### 注册式单例

```java
// 容器缓存的写法
public class ContainerSingleton {

    private ContainerSingleton() {}

    private static Map<String, Object> ioc = new ConcurrentHashMap<>();

    public static Object getBean(String className) {
        synchronized (ioc) {
            if (!ioc.containsKey(className)) {
                Object obj = null;
                try {
                    obj = Class.forName(className).newInstance();
                } catch (Exception e) {
                    e.printStackTrace();
                }
                return obj;
            } else {
                return ioc.get(className);
            }
        }
    }
}
```

容器式写法适用于创建实例非常多的情况，便于管理