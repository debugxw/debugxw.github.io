---
title: 平衡二叉排序树
excerpt: 能实现高效查询、插入、删除等操作的高度平衡的二叉搜索树
date: 2019-04-10 17:22:40
tags: 数据结构
image: /img/theme/017.jpg
---

## 一、概述
平衡二叉排序树又称 AVL 树。一颗 AVL 树或者是空树，或者是具有下列性质的二叉排序树：
+ 左子树与右子树的高度之差的绝对值小于等于 1
+ 左子树和右子树也是 AVL 树

引入 AVL 树的目的是为了提高查找效率，其平均查找长度为 O(logN)。同时，AVL 树也很好的解决了二叉排序树在极端情况下退化成链表的问题。

**局限性**
虽然 AVL 树的查找效率很高，但由于维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多（Windows 对进程地址空间的管理用到了 AVL 树），更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果应用场景中对插入删除不频繁，只是对查找要求较高，那么 AVL 树还是较优于红黑树。

## 二、插入
AVL 树节点的平衡因子定义为：节点的左子树深度与右子树深度之差。显然对于一颗 AVL 树而言，其所有节点的平衡因子只能是 -1、0 或 1。当在一颗 AVL 树上插入一个节点时，有可能导致失衡，即出现平衡因子大于 1 或 小于 -1 的节点。在这种情况下，为了恢复平衡就要对 AVL 树进行相应的调整。失衡类型及相应的调整方法可归结为以下四种。
### 1、LL 型
假设最底层失衡节点为 A，在节点 A 的左子树的左子树插入新节点 S 后导致失衡，如图所示。

<center>
<img src="../../../../img/data_structure/avl_LL.png" width="60%" height="60%" />
</center>

由上可知，LL 型失衡的特点是 A.bf = 2, B.bf = 1 (bf 是节点的平衡因子)。为恢复平衡，可将 B 的右子树改为 A 的左子树，然后把 A 改为 B 的右子树。这相当于以 B 为轴，对 A 做了一次顺时针旋转。这时，A 和 B 的平衡因子都变为 0。最后，将调整后二叉树的根节点 B 接到原来的 A 处。设 A 原来的父节点为 FA，如果 FA 非空，则用 B 代替 A 做 FA 的左子树或右子树；否则原来 A 就是根节点，此时应令根指针指向 B。
### 2、LR 型
假设最底层失衡节点为 A，在节点 A 的左子树的右子树插入新节点 S 后导致失衡，如图所示。

<center>
<img src="../../../../img/data_structure/avl_LR.png" width="60%" height="60%" />
</center>

这里假设 CL 下插入 S，如果是在 CR 下插入 S，对树的调整方法相同，只是调整后 A、B 的平衡因子不同。由 A、B、C 的平衡因子容易推知，CL 与 CR 深度相同，BL 与 AR 深度相同且 BL、AR 的深度比 CL、CR 的深度大 1。为恢复平衡并保持 AVL 树的特性，可先将 B 改为 C 的左子树，而 C 原来的左子树改为 B 的右子树；然后将 A 改为 C 的右子树，C 原来的右子树改为 A 的左子树。这相当于**对 B 做了一次逆时针旋转，对 A 做了一次顺时针旋转**。

上面提到了在 CL 下插入 S 和在 CR 下插入 S 的两种情况，还有一种情况是 B 的右子树为空，C 本生就是插入的新节点 S，此时，CL、CR、BL、AR 均为空。在这种情况下，对树的调整方法任然相同，只是调整后 A、B 的平衡因子均为 0。
LR 型失衡的特点是 A.bf = 2, B.bf = -1。最后，将调整的二叉树的根节点 C 接到原来的 A 处。设 A 原来的父节点为 FA，如果 FA 非空，则用 C 代替 A 做 FA 的左子树或右子树；否则原来 A 就是根节点，此时应令根指针指向 C。
### 3、RR 型
RR 型与 LL 型对称。假设最底层失衡节点为 A，在节点 A 的右子树的右子树插入新节点 S 后导致失衡，如图所示。

<center>
<img src="../../../../img/data_structure/avl_RR.png" width="60%" height="60%" />
</center>

由上可知，RR 型失衡的特点是 A.bf = -2, B.bf = -1。为恢复平衡，可将 B 的左子树改为 A 的右子树，然后把 A 改为 B 的左子树。这相当于以 B 为轴，对 A 做了一次逆时针旋转。这时，A 和 B 的平衡因子都变为 0。最后，将调整后二叉树的根节点 B 接到原来的 A 处。设 A 原来的父节点为 FA，如果 FA 非空，则用 B 代替 A 做 FA 的左子树或右子树；否则原来 A 就是根节点，此时应令根指针指向 B。
### 4、RL 型
RL 型与 LR 型对称。假设最底层失衡节点为 A，在节点 A 的右子树的左子树插入新节点 S 后导致失衡，如图所示。

<center>
<img src="../../../../img/data_structure/avl_RL.png" width="60%" height="60%" />
</center>

这里假设 CR 下插入 S，如果是在 CL 下插入 S，对树的调整方法相同，只是调整后 A、B 的平衡因子不同。由 A、B、C 的平衡因子容易推知，CL 与 CR 深度相同，AL 与 BR 深度相同且 AL、BR 的深度比 CL、CR 的深度大 1。为恢复平衡并保持 AVL 树的特性，可先将 B 改为 C 的右子树，而 C 原来的右子树改为 B 的左子树；然后将 A 改为 C 的左子树，C 原来的左子树改为 A 的右子树。这相当于**对 B 做了一次顺时针旋转，对 A 做了一次逆时针旋转**。

上面提到了在 CL 下插入 S 和在 CR 下插入 S 的两种情况，还有一种情况是 B 的左子树为空，C 本生就是插入的新节点 S，此时，CL、CR、AL、BR 均为空。在这种情况下，对树的调整方法任然相同，只是调整后 A、B 的平衡因子均为 0。
RL 型失衡的特点是 A.bf = -2, B.bf = 1。最后，将调整的二叉树的根节点 C 接到原来的 A 处。设 A 原来的父节点为 FA，如果 FA 非空，则用 C 代替 A 做 FA 的左子树或右子树；否则原来 A 就是根节点，此时应令根指针指向 C。
### 5、插入代码
```java
public class SaluteAVLTree<T extends Comparable> {

    private Node<T> root;

    static class Node<T> {
        T value;
        int bf;     //平衡因子
        Node<T> leftChild;
        Node<T> rightChild;

        Node(T value) {
            this.value = value;
            this.bf = 0;
            this.leftChild = null;
            this.rightChild = null;
        }
    }

    public void add(T value) {
        Node<T> newNode = new Node<>(value);
        if (root == null)
            root = newNode;
        else {
            /**
             * 首先查找 S 的插入位置 fp，同时记录距 S 的插入位置最近且平衡因子
             * 不等于0（等于-1或1）的节点 A，A 为可能的失衡节点
             */
            Node<T> A = root; Node<T> FA = null;
            Node<T> p = root; Node<T> fp = null;
            while (p != null) {
                if (p.bf != 0) {
                    A = p;
                    FA = fp;
                }
                fp = p;
                if (value.compareTo(p.value) < 0)
                    p = p.leftChild;
                else if (value.compareTo(p.value) > 0)
                    p = p.rightChild;
                else
                    return ;
            }
            if (value.compareTo(fp.value) < 0)
                fp.leftChild = newNode;
            else
                fp.rightChild = newNode;

            /**
             * 确定节点 B，并修改节点 A 的平衡因子
             */
            Node<T> B;
            if (value.compareTo(A.value) < 0) {
                B = A.leftChild;
                A.bf = A.bf + 1;
            } else {
                B = A.rightChild;
                A.bf = A.bf - 1;
            }

            /**
             * 修改 B 到 newNode 路径上各节点的平衡因子（原值均为0）
             */
            p = B;
            while (p != newNode) {
                if (value.compareTo(p.value) < 0) {
                    p.bf = 1;
                    p = p.leftChild;
                } else {
                    p.bf = -1;
                    p = p.rightChild;
                }
            }

            /**
             * 判断失衡类型并做相应处理
             */
            if (A.bf == 2 && B.bf == 1) {     /* LL型 */
                A.leftChild = B.rightChild;
                B.rightChild = A;
                A.bf = 0;
                B.bf = 0;
                if (FA == null) root = B;
                else if (FA.leftChild == A) FA.leftChild = B;
                else FA.rightChild = B;
            }
            else if (A.bf == 2 && B.bf == -1) {       /* LR型 */
                Node<T> C = B.rightChild;
                B.rightChild = C.leftChild;
                A.leftChild = C.rightChild;
                C.leftChild = B;
                C.rightChild = A;
                /* 分别对应三种不同的情况设置平衡因子 */
                int compare = newNode.value.compareTo(C.value);
                if (compare < 0) {
                    A.bf = -1;
                    B.bf = 0;
                } else if (compare > 0) {
                    A.bf = 0;
                    B.bf = 1;
                } else {
                    A.bf = 0;
                    B.bf = 0;
                }
                if (FA == null) root = C;
                else if (FA.leftChild == A) FA.leftChild = C;
                else FA.rightChild = C;
            }
            else if (A.bf == -2 && B.bf == 1) {       /* RL型 */
                Node<T> C = B.leftChild;
                A.rightChild = C.leftChild;
                B.leftChild = C.rightChild;
                C.leftChild = A;
                C.rightChild = B;
                /* 分别对应三种不同的情况设置平衡因子 */
                int compare = newNode.value.compareTo(C.value);
                if (compare < 0) {
                    A.bf = 0;
                    B.bf = -1;
                } else if (compare > 0) {
                    A.bf = 1;
                    B.bf = 0;
                } else {
                    A.bf = 0;
                    B.bf = 0;
                }
                if (FA == null) root = C;
                else if (FA.leftChild == A) FA.leftChild = C;
                else FA.rightChild = C;
            }
            else if (A.bf == -2 && B.bf == -1) {      /* RR型 */
                A.rightChild = B.leftChild;
                B.leftChild = A;
                A.bf = 0;
                B.bf = 0;
                if (FA == null) root = B;
                else if (FA.leftChild == A) FA.leftChild = B;
                else FA.rightChild = B;
            }
        }
    }

    private void inorder(Node<T> r) {
        if (null != r) {
            inorder(r.leftChild);
            System.out.print(r.value + " ");
            inorder(r.rightChild);
        }
    }

    // 中序输出
    public void inorderTraversal() {
        inorder(root);
        System.out.println();
    }
}
```

## 三、删除
当从 AVL 树中删除一个节点时，有可能会导致 AVL 树失衡，为了恢复平衡就要对 AVL 树做相应的调整。对于待删除节点 X，存在以下四种情况：
1. X 为叶子节点，即 X 的左右子树都为空。这时可以直接将 X 删除，并依次向上回溯调整相应节点的高度 height
2. X 的左子树不为空，右子树为空。因为原来的 X 是平衡的，所以如果右子树为空，那么 X 的左子树的高度一定为 1，即左子树只有一个节点。这时只需用 X 的左子树来替换 X，并依次向上回溯调整相应节点的高度 height 即可
3. X 的左子树为空，右子树不为空（和情况二对称）。因为原来的 X 是平衡的，所以如果左子树为空，那么 X 的右子树的高度一定为 1，即右子树只有一个节点。这时只需用 X 的右子树来替换 X，并依次向上回溯调整相应节点的高度 height 即可
4. X 的左右子树都不为空。这种情况和 BST 的删除类似，只不过多了一步调整树的高度而已。需要先用 X 的左子树的最大值（即中序遍历下 X 的先驱节点）来替换 X 的值，然后删除 X 的先驱节点即可，而删除先驱节点必定会转换为情况 1 或 2。也可以先用 X 的右子树的最小值（即中序遍历下 X 的后继节点）来替换 X 的值，然后删除 X 的后继节点，如果使用这种方式，那么删除后继节点必定会转换为情况 1 或 3。

**补充——二叉排序树（Binary Sort Tree, BST）的删除**
BST 的删除分为三种情况（假设待删除节点为 P，P 的父节点为 F）：
1. P 为叶节点，直接删除
2. P 只有左子树或只有右子树，则可将 P 的左子树或右子树，直接改为其父节点 F 的左子树或右子树
3. P 既有左子树，又有右子树，此时有两种处理方法：
  + 首先找到 P 节点在中序遍历中的直接前驱 S 节点，然后将 P 的左子树改为 F 的左子树，而将 P 的右子树改为 S 的右子树（如图 a）
  + 首先找到 P 节点在中序遍历中的直接前驱 S 节点，然后用 S 节点的值代替 P 节点的值，再将 S 节点删除，原 S 节点的左子树改为 S 的父节点 Q 的右子树（如图b）

<center><img src="../../../../img/data_structure/bst_delete.png" width="80%" height="80%" /></center>

## 四、完整源代码
这里的代码不再使用 bf，取而代之的是 height，代表以该节点为根的树的高度，平衡因子的就可以表示为左子树的高度减去右子树的高度。
```java
public class AVLTree<T extends Comparable> {

    private Node<T> root;

    static class Node<T> {

        T value;
        int height;
        Node<T> leftChild;
        Node<T> rightChild;

        Node(T value) {
            this.value = value;
            this.height = 1;
            this.leftChild = null;
            this.rightChild = null;
        }
    }

    // LL型失衡，右旋，返回旋转后的根节点
    private Node<T> LLRotate(Node<T> A) {
        Node<T> B = A.leftChild;
        A.leftChild = B.rightChild;
        B.rightChild = A;
        A.height = Math.max(height(A.leftChild), height(A.rightChild)) + 1;
        B.height = Math.max(height(B.leftChild), height(B.rightChild)) + 1;
        return B;
    }

    //LR型失衡，先左旋再右旋，返回旋转后的根节点
    private Node<T> LRRotate(Node<T> A) {
        A.leftChild = RRRotate(A.leftChild);
        return LLRotate(A);
    }

    //RL型失衡，先右旋再左旋，返回旋转后的根节点
    private Node<T> RLRotate(Node<T> A) {
        A.rightChild = LLRotate(A.rightChild);
        return RRRotate(A);
    }

    // RR失衡，左旋，返回旋转后的根节点
    private Node<T> RRRotate(Node<T> A) {
        Node<T> B = A.rightChild;
        A.rightChild = B.leftChild;
        B.leftChild = A;
        A.height = Math.max(height(A.leftChild), height(A.rightChild)) + 1;
        B.height = Math.max(height(B.leftChild), height(B.rightChild)) + 1;
        return B;
    }

    public void add(T data) {
        root = add(root, data);
    }

    // 添加节点，返回子树根节点
    public Node<T> add(Node<T> node, T value) {
        if (node == null)
            return new Node<>(value);

        int cmp = node.value.compareTo(value);
        if (cmp > 0) {
            node.leftChild = add(node.leftChild, value);
            if (height(node.leftChild) - height(node.rightChild) == 2) {
                if (node.leftChild.value.compareTo(value) > 0) {
                    node = LLRotate(node);
                } else {
                    node = LRRotate(node);
                }
            }
        } else if (cmp < 0) {
            node.rightChild = add(node.rightChild, value);
            if (height(node.leftChild) - height(node.rightChild) == -2) {
                if (value.compareTo(node.rightChild.value) > 0) {
                    node = RRRotate(node);
                } else {
                    node = RLRotate(node);
                }
            }
        } else {
            return null;
        }

        // 调整树的高度
        node.height = Math.max(height(node.leftChild), height(node.rightChild)) + 1;
        return node;
    }

    public boolean remove(T value) {
        if (contains(value) == false)
            return false;
        remove(root, value);
        return true;
    }

    // 删除节点，返回子树根节点
    private Node<T> remove(Node<T> node, T value) {
        if (node == null)
            return null;

        int cmp = node.value.compareTo(value);
        if (cmp > 0) {
            node.leftChild = remove(node.leftChild, value);
            if (height(node.leftChild) - height(node.rightChild) == -2) {
                Node<T> tem = node.rightChild;
                if (height(tem.leftChild) > height(tem.rightChild)) {
                    node = RLRotate(node);
                } else {
                    node = RRRotate(node);
                }
            }
        } else if (cmp < 0) {
            node.rightChild = remove(node.rightChild, value);
            if (height(node.leftChild) - height(node.rightChild) == 2) {
                Node<T> tem = node.leftChild;
                if (height(tem.leftChild) < height(tem.rightChild)) {
                    node = LRRotate(node);
                } else {
                    node = LLRotate(node);
                }
            }
        } else {
            if (node.leftChild == null && node.rightChild == null) {
                return null;
            } else if (node.leftChild != null && node.rightChild == null) {
                node = node.leftChild;
            } else if (node.leftChild == null && node.rightChild != null) {
                node = node.rightChild;
            } else {
                Node<T> tem = node.leftChild;
                while (tem.rightChild != null) {
                    tem = tem.rightChild;
                }
                node.value = tem.value;
                node.leftChild = remove(node.leftChild, tem.value);
            }
        }

        // 调整树的高度
        node.height = Math.max(height(node.leftChild), height(node.rightChild)) + 1;
        return node;
    }

    private int height(Node<T> node) {
        return node == null ? 0 : node.height;
    }

    // 判断是否含有某个节点
    public boolean contains(T value) {
        if (root != null) {
            Node<T> p = root;
            int compare;
            while (p != null) {
                compare = value.compareTo(p.value);
                if (compare == 0) return true;
                else if (compare < 0)
                    p = p.leftChild;
                else
                    p = p.rightChild;
            }
        }
        return false;
    }

    private void inorder(Node<T> r) {
        if (null != r) {
            inorder(r.leftChild);
            System.out.print(r.value + " ");
            inorder(r.rightChild);
        }
    }

    // 中序输出
    public void inorderTraversal() {
        inorder(root);
        System.out.println();
    }
}
```
