---
title: MySQL索引
excerpt: 帮助MySQL实现高效数据查询的一种数据结构
date: 2019-03-19 16:54:34
tags: [MySQL,存储]
image: /img/theme/014.jpg
---

### 一、索引概述

索引是帮助MySQL高效获取数据的一种数据结构。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高效查找算法。一句话，索引就是为了实现高效的数据查询的一种数据结构。例如像哈希表、有序数组、跳表、平衡二叉树、红黑树、B-Tree、B+Tree这些数据结构都能够实现高效的数据查询，但是他们之中谁更加适合作为数据库的索引呢？（如未作说明，以下讨论均基于InnoDB）


### 二、什么样的数据结构适合作为索引

#### 哈希索引

哈希表的查询效率非常的高，几乎可以达到惊人的O(1)，但哈希表却并不适合作为数据库的索引结构，主要原因如下：
+ 不支持范围查询，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询
+ 同理，哈希索引也没办法利用索引完成排序，以及```like 'xxx%'```这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）
+ 哈希索引也不支持多列联合索引
+ 在有大量重复键值的情况下，哈希索引的效率会急剧下降，因为存在所谓的哈希碰撞问题

但是哈希表也不是完全不能作为数据库的索引，因为如果是等值查询，那么哈希索引明显有绝对优势。例如像基于内存的Memory存储引擎默认的索引结构就是哈希索引

#### 有序数组/跳表

有序数组和跳表的查询效率分别能达到O(logN)和O(log2N)，查询效率非常高。但是，我们在选择适合作为数据库索引的数据结构时，还要考虑到一个问题：一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。另外，数组的插入和删除效率也非常低。考虑到这些因素，有序数组和跳表并不适合作为数据库的索引结构，而树形结构才是最佳之选

#### 平衡二叉树/红黑树/B-Tree

平衡二叉树的平均查找时间复杂度为O(log2N)，红黑树的平均查找时间复杂度为O(logN)，虽然他们的查询效率很高，但他们却并不适合作为数据库的索引。而最适合作为数据库索引的是B-Tree

**B-Tree更适合作为索引**
难道B-Tree的查询时间复杂度更低吗？并不是，但它查找的时间复杂度也近似O(log2N)。前面提到过，索引文件往往是存储在磁盘中的，如果要查询某条记录，就要进行磁盘I/O操作。这里就涉及到计算机科学中的局部性原理和磁盘预读：
> 局部性原理与磁盘预读:
>> 由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理： 
当一个数据被用到时，其附近的数据也通常会马上被使用。 
程序运行期间所需要的数据通常比较集中。 
由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率

像平衡二叉树，红黑树这种结构，其深度明显要比B-Tree深的多。由于逻辑上很近的节点（父子）物理（磁盘）上可能相距很远，每次磁盘预读中的很多数据是用不上的数据，无法利用局部性，所以红黑树要进行更多的I/O操作，效率明显比B-Tree差很多。而B树的每个节点可以存储多个关键字，它将节点大小设置为磁盘页的大小（每次新建一个节点的同时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O），充分利用了磁盘预读的功能。每次读取磁盘页时就会读取一整个节点。也正因每个节点存储着非常多个关键字，树的深度就会非常的小。进而要执行的磁盘I/O操作次数就会非常少，更多的是在内存中对读取进来的数据进行查找。
B树的查询，主要发生在内存中，而平衡二叉树或红黑树的查询，则主要是发生在磁盘读取中。因此，虽然B-Tree查询的次数不比平衡二叉树或红黑树的次数少，但是相比起磁盘I/O速度，内存中比较的耗时就可以忽略不计了。因此，B-Tree更适合作为索引。

#### B+Tree

比B-Tree更适合作为索引的结构——B+Tree。这里引用两段话：
> 走进搜索引擎的作者梁斌老师针对B树、B+树给出了他的意见（为了真实性，特引用其原话，未作任何改动）：
“B+树还有一个最大的好处，方便扫库，B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持。这是数据库选用B+树的最主要原因。 
比如要查 5-10之间的，B+树一把到5这个标记，再一把到10，然后串起来就行了，B树就非常麻烦。B树的好处，就是成功查询特别有利，因为树的高度总体要比B+树矮。不成功的情况下，B树也比B+树稍稍占一点点便宜。 
B树比如你的例子中查17的话，一把就得到结果了，有很多基于频率的搜索是选用B树，越频繁query的结点越往根上走，前提是需要对query做统计，而且要对key做一些变化。 
另外B树也好B+树也好，根或者上面几层因为被反复query，所以这几块基本都在内存中，不会出现读磁盘IO，一般已启动的时候，就会主动换入内存。”

> 数据库索引采用B+Tree的主要原因是B-Tree在提高了磁盘I/O性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+Tree应运而生。B+Tree只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B-Tree不支持这样的操作（或者说效率太低）。

[更多关于B-Tree、B+Tree、B*Tree点这里](https://www.baidu.com/)

### 三、MySQL的两种存储引擎的索引存储机制

#### MyISAM索引实现

MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。

<center>
<img src="../../../../img/db/index_MyISAM_1.png" width="60%" height="60%" />
</center>

这里设表一共有三列，假设我们以Col1为主键，则上图是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：

<center>
<img src="../../../../img/db/index_MyISAM_2.png" width="60%" height="60%" />
</center>

同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。
MyISAM的索引方式也叫做“非聚集索引”。

#### InnoDB索引实现

虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。

<center>
<img src="../../../../img/db/index_InnoDB_1.png" width="60%" height="60%" />
</center>

上图是InnoDB主键索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。
第二个与MyISAM索引的不同是InnoDB的非主键索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有非主键索引都引用主键作为data域。例如，定义在Col3上的一个非主键索引：

<center>
<img src="../../../../img/db/index_InnoDB_2.png" width="60%" height="60%" />
</center>

这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是非主键索引搜索需要检索两遍索引：首先检索非主键索引获得主键，然后用主键到主键索引中检索获得记录。

### 四、索引的分类
+ 普通索引：基本的索引，它没有任何限制
+ 唯一索引：与普通索引类似，不同的就是：MySQL数据库索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。
+ 主键索引：一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引。
+ 全文索引：全文检索是对大数据文本进行索引，在建立的索引中对要查找的单词进行进行搜索，定位哪些文本数据包括要搜索的单词。因此，全文检索的全部工作就是建立索引和在索引中搜索定位，所有的工作都是围绕这两个来进行的。建立全文索引中有两项非常重要，一个是如何对文本进行分词，一是建立索引的数据结构。分词的方法基本上是二元分词法、最大匹配法和统计方法。索引的数据结构基本上采用倒排索引的结构。分词的好坏关系到查询的准确程度和生成的索引的大小。MySQL中的MyISAM支持全文索引，而InnoDB不支持。

### 五、覆盖索引

上面提到，对于非主键索引的查询，会先查询记录对应的主键，再去主键索引查询记录。在这个过程中，回到主键索引树搜索的过程，我们称为回表。
但是，如果非主键索引已经包含了全部的待查询字段，那么此时InnoDB就不会进行回表操作，而是直接返回。例如如下查询：

```sql
-- 表结构
create table T (
    id int primary key,
    a varchar(16) NOT NULL DEFAULT '',
    b int NOT NULL DEFAULT 0,
    index idx_a(a)
)engine=InnoDB;
```

```sql
-- 查询语句1
select id, a, b from T where a = 'abc';    -- 1次回表

-- 查询语句2
select id, a from T where a = 'abc'; -- 0次回表
```

在上面的查询语句1当中，通过idx_a索引并不能查询到b字段，所以会先查询idx_a索引，拿到主键，再去主键索引中查询，回表次数为1。
而在查询语句2当中，非主键索引idx_a已经包含了全部的待查询字段（id, a），所以InnoDB在非主键索引树上查询到数据后就会直接返回，回表次数为0。
像idx_a这种已经“覆盖”了我们的查询需求的索引，我们称之为覆盖索引。**由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段**

### 六、多列索引（组合索引）

```sql
--相当于创建了(name)单列索引，(name, age)组合索引以及(name, age, sex)组合索引
ALTER TABLE people ADD INDEX height_name_age (name, age, sex);
```

**最左前缀原则：**在mysql建立联合索引时会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。
+ B+Tree的数据项是复合的数据结构，比如上面的(name, age, sex)，B+Tree是按照从左到右的顺序来建立搜索树的，比如当(张三, 20, 男)这样的数据来检索的时候，B+Tree会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据。当(20, 男)这样的没有name的数据来的时候，B+Tree就不知道第一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。
+ 比如当(张三, 男)这样的数据来检索时，b+Tree可以用name来指定搜索方向，但由于字段age的缺失而无法和左前缀连接，所以只能把名字等于张三的数据都找到，然后再对sex进行过滤，这个是非常重要的性质，即索引的最左匹配特性（这种情况无法用到联合索引）。如果想让sex也使用索引而不是where过滤，有以下两种方法：   
   + 增加一个辅助索引，此时上面的查询就会使用到这个索引
   + 使用一种称之为“隔离列”的优化方法，将name与sex之间的“坑”填上
    > 如果age的值只有 (19, 20, 21) 三种，可以考虑用"IN"来填补这个坑从而形成最左前缀。
SELECT * FROM people WHERE name = '张三' AND age IN (19, 20, 21) AND sex = '男';
这样的话就是用了 (name, age, sex) 索引，但是 IN 实际上执行了一个 range 查询，这里检查了3个key（具体可用 explain 查看）。“填坑”后性能提升了一点。如果经过 name 筛选后余下很多数据，则后者性能优势会更加明显。当然，如果 age 的值很多，用填坑就不合适了，必须建立辅助索引。
+ 匹配某列的前缀字符串时，如果通配符%不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀。
+ 如果查询条件中含有函数或表达式，则MySQL不会为这列使用索引。
+ 关于最左前缀原则
   + 最左前缀匹配原则，mysql 会一直向右匹配直到遇到范围查询 (>、<、between、like) 就停止匹配，比如 a = 1 and b = 2 and c > 3 and d = 4 如果建立 (a, b, c, d) 顺序的索引，d 是用不到索引的，如果建立 (a, b, d, c) 的索引则都可以用到，a, b, d 的顺序可以任意调整。
   + 进行精确匹配（指 = 或 in 的匹配）时可以乱序，比如 a = 1 and b = 2 and c = 3 建立 (a, b, c) 索引可以任意顺序，mysql 的查询优化器会自动调整 where 子句的条件顺序以使用合适的索引。

**为什么条件查询中有函数、范围查询遇到!=等就用不到索引**
假设我们在a字段上面建立了索引，那么这个索引树（也就是B+Tree）中节点存储的就是a字段的值，所以我们可以用a的等值查询来检索，例如：

```sql
select * from T where a = 'abc';
```

因为是等值查询所以可以直接通过a的索引树定位到'abc'（如果定位不到，那么说明记录不存在）。但是如果我在查询条件中增加了函数计算，例如：

```sql
select * from from T where concat(a, 'str') = 'abc';
```

这个时候是肯定用不到a这个索引的，查询条件是concat(a, 'str')，但是a索引存储的是a的值，MySQL并不知道到concat(a, 'str')函数计算之后是个什么东西，所以只能一个一个记录的去遍历，做函数计算，然后再来判断。
当遇到!=这样的操作符时，也是一样的道理，只能一个一个记录的去遍历，而无法使用到这个索引。

**为什么最左前缀原则中范围查询后面的字段用不到索引**
假设有如下查询：

```sql
create table T (
    id int primary key,
    a varchar(16) NOT NULL DEFAULT '',
    b int NOT NULL DEFAULT 0,
     int NOT NULL DEFAULT 0,
    index idx_a_b_c(a, b, c)
)engine=InnoDB;

select * from T where a = '111' and b > 10 and c = 30;
```

虽然我们创建了联合索引idx_a_b_c，但是由于b属于范围查询，所以关于c的索引是使用不到的。假设这个表有如下记录：

```java
(111, 8, 30),(111, 11, 20),(111, 11, 30),(111, 11, 25),(111, 16, 20),(112, 8, 30)
```

上面这条查询首先通过a索引定位到(111, , )，再通过b定位到(111, 11, 20)，因为在b字段上面使用的是范围查询>，所以当定位到(111, 11, 20)这个记录时，后面的记录中的b都是大于10的，但是并不能确定后面的记录中c字段是否满足查询条件，因为b>10的记录有可能c不等于30，例如(111, 14, 25)，所以只能一个一个的去向后遍历，那么也就只能用到a、b的索引，而用不到c的索引


### 七、索引下推

上文提到满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。那些不符合最左前缀的部分，会怎么样呢？我们以用户表为例，表结构如下：

```sql
CREATE TABLE `user` (
    `id` int(11) NOT NULL,
    `name` varchar(32) DEFAULT NULL,
    `age` int(11) DEFAULT NULL,
    `ismale` tinyint(1) DEFAULT NULL,
    PRIMARY KEY (`id`),
    KEY `name_age` (`name`,`age`)
) ENGINE=InnoDB
```

假设现在需要检索出表中“名字第一个字是张，而且年龄是10岁的所有男孩”。那么，SQL 语句是这么写的：

```sql
select * from user where name like '张%' and age=10 and ismale=1;
```

显然，这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录，假设为ID3，然后判断其他条件是否满足
在MySQL 5.6之前，只能从X开始一个个回表。到主键索引上找出数据行，再对比字段值
而MySQL 5.6引入的<font color='red'>**索引下推**</font>优化（index condition pushdown），可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数
这两个过程分别如下图所示：

![无索引下推执行流程](../../../../img/db/%E6%97%A0%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8.png)

![索引下推执行流程](../../../../img/db/%E6%9C%89%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8.png)

> 参考：
https://blog.csdn.net/weixin_30531261/article/details/79312676
https://www.jianshu.com/p/1775b4ff123a
https://www.kancloud.cn/kancloud/theory-of-mysql-index/41857
https://www.cnblogs.com/wezheng/p/8399305.html
