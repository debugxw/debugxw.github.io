---
title: JVM类加载机制
excerpt: 将Java字节码文件加载到内存中，并在运行时动态链接和初始化类的过程
date: 2019-07-24 08:56:16
tags: Java
image: /img/theme/016.jpg
---

JVM 把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。
与那些在编译时需要进行连接工作的语言不同，**在 Java 语言里，类型的加载、连接和初始化过程都是在程序运行期间完成的**，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为 Java 应用程序提供高度的灵活性，Java 里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态链接这个特点实现的。例如，如果编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类；用户可以通过 Java 预定义的和自定义类加载器，让一个本地的应用程序可以在运行时从网络或者其他的地方加载一个二进制流作为程序代码的一部分，这种组装应用程序的方式目前已广泛应用于 Java 程序中。

## 一、类加载过程

<center><img src="../../../../img/jdk/classLoadingProcess.png" width="60%" height="60%" /></center>

### 1、加载
+ 通过一个类的全限定名来获取其定义的二进制字节流。
+ 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
+ 在 Java 堆中生成一个代表这个类的 java.lang.Class 对象，作为对方法区中这些数据的访问入口。

### 2、验证
验证的目的是为了**确保 Class 文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全**。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：
a、文件格式的验证：验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。
b、元数据验证：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合 Java 语法规范的元数据信息。
c、字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。
d、符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。

### 3、准备
**正式为类变量分配内存并设置类变量初始值的阶段**，这些内存都将在方法区中分配。
注意：这时候进行内存分配的仅包括被 static 修饰的类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。其次，这里所说的初始值通常情况下是数据类型的零值，假设一个类变量的定义为：
public static int value = 123;
那变量 value 在准备阶段过后的初始值为 0 而不是 123，因为这时候尚未开始执行任何 Java 方法，而把 value 赋值为 123 的 putstatic 指令是程序被编译后，存放于类构造器 <clinit>() 方法之中，所以把 value 赋值为 123 的动作将在初始化阶段才会执行。

### 4、解析
**解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。**
**符号引用：**符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中。
**直接引用：**直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。

### 5、初始化
执行类中定义的 Java 程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器 ＜clinit＞() 方法的过程。

**＜clinit＞() 方法的执行规则：**
**a、**＜clinit＞() 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，**编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句中可以赋值，但是不能访问**。
**b、**＜clinit＞() 方法与实例构造器 ＜init＞() 方法（类的构造函数）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的 ＜clinit＞() 方法执行之前，父类的 ＜clinit＞() 方法已经执行完毕。因此，在虚拟机中第一个被执行的 ＜clinit＞() 方法的类肯定是 java.lang.Object。
**c、**＜clinit＞() 方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成 ＜clinit＞() 方法。
**d、**接口中不能使用静态语句块，但仍然有类变量 (final static) 初始化的赋值操作，因此接口与类一样会生成 ＜clinit＞() 方法。但是接口与类不同的是：执行接口的 ＜clinit＞() 方法不需要先执行父接口的 ＜clinit＞() 方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的 ＜clinit＞() 方法。
**e、**虚拟机会保证一个类的 ＜clinit＞() 方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 ＜clinit＞() 方法，其他线程都需要阻塞等待，直到活动线程执行 ＜clinit＞() 方法完毕。如果在一个类的 ＜clinit＞() 方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。

## 二、类加载器和双亲委派模型
对于任意一个类，都需要由它的类加载器和这个类本身一同确定其在就 Java 虚拟机中的唯一性，也就是说，即使两个类来源于同一个 Class 文件，只要加载它们的类加载器不同，那这两个类就必定不相等。这里的 "相等" 包括了代表类的 Class 对象的 equals()、isAssignableFrom()、isInstance() 等方法的返回结果，也包括了使用 instanceof 关键字对对象所属关系的判定结果。

站在 Java 虚拟机的角度来讲，只存在两种不同的类加载器：
**启动类加载器：**它使用 C++ 实现（这里仅限于 Hotspot，也就是 JDK1.5 之后默认的虚拟机，有很多其他的虚拟机是用 Java 语言实现的），是虚拟机自身的一部分。
**所有其他的类加载器：**这些类加载器都由 Java 语言实现，独立于虚拟机之外，并且全部继承自抽象类 java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。

站在 Java 开发人员的角度来看，类加载器可以大致划分为以下三类：
**启动类加载器：**Bootstrap ClassLoader，跟上面相同。它负责加载存放在 JDK\jre\lib(JDK 代表 JDK 的安装目录，下同)下，或被 -Xbootclasspath 参数指定的路径中的，并且能被虚拟机识别的类库（如 rt.jar，所有的 java.\* 开头的类均被 Bootstrap ClassLoader 加载）。启动类加载器是无法被 Java 程序直接引用的，它负责加载 java 核心库。
**扩展类加载器：**Extension ClassLoader，该加载器由 sun.misc.Launcher$ExtClassLoader 实现，它负责加载 JDK\jre\lib\ext 目录中，或者由 java.ext.dirs 系统变量指定的路径中的所有类库（如 javax.\* 开头的类），开发者可以直接使用扩展类加载器，它负责加载 java 扩展库。
**应用程序类加载器：**Application ClassLoader，该类加载器由 sun.misc.Launcher$AppClassLoader 来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

**自定义类加载器（可以做到如下几点）：**
+ 在执行非置信代码之前，自动验证数字签名。
+ 动态地创建符合用户特定需要的定制化构建类。
+ 从特定的场所取得 java class，例如数据库中和网络中。

### 双亲委派模型

<center><img src="../../../../img/jdk/parentDelegationModel.png" width="20%" height="20%" /></center>

这种层次关系称为类加载器的双亲委派模型。我们把每一层上面的类加载器叫做当前层类加载器的父加载器，当然，它们之间的父子关系并不是通过继承关系来实现的，而是使用组合关系来复用父加载器中的代码。该模型在 JDK1.2 期间被引入并广泛应用于之后几乎所有的 Java 程序中，但它并不是一个强制性的约束模型，而是 Java 设计者们推荐给开发者的一种类的加载器实现方式。

**双亲委派模型工作流程：**
如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。
使用双亲委派模型来组织类加载器之间的关系，有一个很明显的好处，**就是 Java 类随着它的类加载器（说白了，就是它所在的目录）一起具备了一种带有优先级的层次关系，这对于保证 Java 程序的稳定运作很重要**。例如，类 java.lang.Object 类存放在 JDK\jre\lib 下的 rt.jar 之中，因此无论是哪个类加载器要加载此类，最终都会委派给启动类加载器进行加载，这便保证了 Object 类在程序中的各种类加载器中都是同一个类。

### Tomcat破坏双亲委派模型

**为什么Tomcat要打破双亲委派机制？**
一个Tomcat实例可以部署多个war包，也就是多个Web应用。如果两个Web应用都有一个类Car，且类限定名都为com.xxx.Car，但是他们的实现是不一样的，为了保证这两个类不冲突，Tomcat打破了双亲委派机制

**实现原理**
Tomcat会给每个Web应用程序创建一个类加载实例（WebAppClassLoader），该加载器重写了ClassLoader.loadClass()方法，优先加载当前应用目录下的类。这样就做到了Web应用层级的隔离：

![Tomcat破话双亲委派模型](../../../../img/jdk/tomcat_break_parent.png)

### SPI破坏双亲委派模型

**什么是SPI**
简单理解，就是为某个接口寻找具体实例的机制，例如JDBC驱动
**加载JDBC驱动过程**
当ServiceLoader在加载驱动的时候，实际上使用的是当前线程的上下文类加载器，这个加载器实际上就是应用程序类加载器，在获取链接的时候，首先使用扩展类加载器和启动类加载器，但是这两个加载器肯定是加载不到的，最终由应用程序类加载器进行加载
**这种机制破坏双亲委派机制了吗？**
这点其实有待商榷，网上相关的谈论也很多，这里不做过多讨论（但本质上，双亲委派机制的一个作用就是为了保证JDK基础类能够被正确的加载，这样就不会出现你写一个String类和JDK的String出现冲突的情况）

> 参考：
  《深入理解Java虚拟机：JVM高级特性与最佳实践》
  [【深入Java虚拟机】之四：类加载机制](https://blog.csdn.net/ns_code/article/details/17881581)
  [Tomcat为什么要JAVA破坏双亲委派机制？](https://www.zhihu.com/question/466696410)


